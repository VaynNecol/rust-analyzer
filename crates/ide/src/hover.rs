mod render;

#[cfg(test)]
mod tests;

use std::{iter, ops::Not};

use either::Either;
use hir::{db::DefDatabase, DescendPreference, HasCrate, HasSource, LangItem, Semantics};
use ide_db::{
    base_db::FileRange,
    defs::{Definition, IdentClass, NameRefClass, OperatorClass},
    famous_defs::FamousDefs,
    helpers::pick_best_token,
    FxIndexSet, RootDatabase,
};
use itertools::Itertools;
use syntax::{ast, match_ast, AstNode, AstToken, SyntaxKind::*, SyntaxNode, T};

use crate::{
    doc_links::{token_as_doc_comment, external_docs},
    markdown_remove::remove_markdown,
    markup::Markup,
    navigation_target::UpmappingResult,
    runnables::{runnable_fn, runnable_mod},
    FileId, FilePosition, NavigationTarget, RangeInfo, Runnable, TryToNav,
};
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct HoverConfig {
    pub links_in_hover: bool,
    pub memory_layout: Option<MemoryLayoutHoverConfig>,
    pub documentation: bool,
    pub keywords: bool,
    pub format: HoverDocFormat,
}

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub struct MemoryLayoutHoverConfig {
    pub size: Option<MemoryLayoutHoverRenderKind>,
    pub offset: Option<MemoryLayoutHoverRenderKind>,
    pub alignment: Option<MemoryLayoutHoverRenderKind>,
    pub niches: bool,
}

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum MemoryLayoutHoverRenderKind {
    Decimal,
    Hexadecimal,
    Both,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum HoverDocFormat {
    Markdown,
    PlainText,
}

#[derive(Debug, Clone)]
pub enum HoverAction {
    Runnable(Runnable),
    Implementation(FilePosition),
    Reference(FilePosition),
    GoToType(Vec<HoverGotoTypeData>),
}

impl HoverAction {
    fn goto_type_from_targets(db: &RootDatabase, targets: Vec<hir::ModuleDef>) -> Option<Self> {
        let targets = targets
            .into_iter()
            .filter_map(|it| {
                Some(HoverGotoTypeData {
                    mod_path: render::path(
                        db,
                        it.module(db)?,
                        it.name(db).map(|name| name.display(db).to_string()),
                    ),
                    nav: it.try_to_nav(db)?.call_site(),
                })
            })
            .collect::<Vec<_>>();
        targets.is_empty().not().then_some(HoverAction::GoToType(targets))
    }
}

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub struct HoverGotoTypeData {
    pub mod_path: String,
    pub nav: NavigationTarget,
}

/// Contains the results when hovering over an item
#[derive(Debug, Default)]
pub struct HoverResult {
    pub markup: Markup,
    pub actions: Vec<HoverAction>,
}

// Feature: Hover
//
// Shows additional information, like the type of an expression or the documentation for a definition when "focusing" code.
// Focusing is usually hovering with a mouse, but can also be triggered with a shortcut.
//
// image::https://user-images.githubusercontent.com/48062697/113020658-b5f98b80-917a-11eb-9f88-3dbc27320c95.gif[]
pub(crate) fn hover(
    db: &RootDatabase,
    frange @ FileRange { file_id, range }: FileRange,
    config: &HoverConfig,
) -> Option<RangeInfo<HoverResult>> {
    let sema = &hir::Semantics::new(db);
    let file = sema.parse(file_id).syntax().clone();
    let mut res = if range.is_empty() {
        // Fixme: need unit tests
        use std::collections::HashMap;
        use serde::{Deserialize, Serialize};
        use lazy_static::lazy_static;

        type Identifier = String;
        #[derive(Debug, Clone, Default, Serialize, Deserialize)]
        struct SpMappingMerge {
            map: HashMap<Identifier, String>,
        }

        lazy_static! {
        static ref MAP: SpMappingMerge = serde_json::from_str(JSON).unwrap();
        }

        fn remove_prefix(s: String) -> Option<String> {
            if let Some(index) = s.find("core/") {
                // 包含"core"的部分及其之前的字符长度
                let length_to_remove = index + "core/".len();
                // 返回从length_to_remove位置开始到字符串末尾的切片
                Some(s[length_to_remove..].to_owned())
            } else if let Some(index) = s.find("std/") {
                let length_to_remove = index + "std/".len();
                // 返回从length_to_remove位置开始到字符串末尾的切片
                Some(s[length_to_remove..].to_owned())
            } else if let Some(index) = s.find("alloc/") {
                let length_to_remove = index + "alloc/".len();
                // 返回从length_to_remove位置开始到字符串末尾的切片
                Some(s[length_to_remove..].to_owned())
            } else {
                // 如果没有找到"core"，则返回原始字符串
                None
            }
        }

        let res = hover_simple(sema, FilePosition { file_id, offset: range.start() }, file, config);
        if res.is_some() {
            let mut res = res.unwrap();

            let doc_link = external_docs(db, FilePosition { file_id, offset: range.start() }, None, None);
            if doc_link.is_some() && doc_link.clone().unwrap().web_url.is_some() {
                let link = remove_prefix(doc_link.clone().unwrap().web_url.unwrap());
                if let Some(link) = link {
                    let doc = res.info.markup.to_string();
                    if MAP.map.get(&link).is_some() {
                        res.info.markup = (*MAP.map.get(&link).unwrap()).to_owned().into();
                    }
                    Some(res)
                } else { Some(res) }
            } else { Some(res) }
        } else { res }

    } else {
        hover_ranged(sema, frange, file, config)
    }?;

    if let HoverDocFormat::PlainText = config.format {
        res.info.markup = remove_markdown(res.info.markup.as_str()).into();
    }
    Some(res)
}

#[allow(clippy::field_reassign_with_default)]
fn hover_simple(
    sema: &Semantics<'_, RootDatabase>,
    FilePosition { file_id, offset }: FilePosition,
    file: SyntaxNode,
    config: &HoverConfig,
) -> Option<RangeInfo<HoverResult>> {
    let original_token = pick_best_token(file.token_at_offset(offset), |kind| match kind {
        IDENT
        | INT_NUMBER
        | LIFETIME_IDENT
        | T![self]
        | T![super]
        | T![crate]
        | T![Self]
        | T![_] => 4,
        // index and prefix ops and closure pipe
        T!['['] | T![']'] | T![?] | T![*] | T![-] | T![!] | T![|] => 3,
        kind if kind.is_keyword() => 2,
        T!['('] | T![')'] => 2,
        kind if kind.is_trivia() => 0,
        _ => 1,
    })?;

    if let Some(doc_comment) = token_as_doc_comment(&original_token) {
        cov_mark::hit!(no_highlight_on_comment_hover);
        return doc_comment.get_definition_with_descend_at(sema, offset, |def, node, range| {
            let res = hover_for_definition(sema, file_id, def, &node, config);
            Some(RangeInfo::new(range, res))
        });
    }

    if let Some((range, resolution)) =
        sema.check_for_format_args_template(original_token.clone(), offset)
    {
        let res = hover_for_definition(
            sema,
            file_id,
            Definition::from(resolution?),
            &original_token.parent()?,
            config,
        );
        return Some(RangeInfo::new(range, res));
    }

    let in_attr = original_token
        .parent_ancestors()
        .filter_map(ast::Item::cast)
        .any(|item| sema.is_attr_macro_call(&item))
        && !matches!(
            original_token.parent().and_then(ast::TokenTree::cast),
            Some(tt) if tt.syntax().ancestors().any(|it| ast::Meta::can_cast(it.kind()))
        );

    // prefer descending the same token kind in attribute expansions, in normal macros text
    // equivalency is more important
    let descended = sema.descend_into_macros(
        if in_attr { DescendPreference::SameKind } else { DescendPreference::SameText },
        original_token.clone(),
    );
    let descended = || descended.iter();

    let result = descended()
        // try lint hover
        .find_map(|token| {
            // FIXME: Definition should include known lints and the like instead of having this special case here
            let attr = token.parent_ancestors().find_map(ast::Attr::cast)?;
            render::try_for_lint(&attr, token)
        })
        // try definitions
        .or_else(|| {
            descended()
                .filter_map(|token| {
                    let node = token.parent()?;
                    match IdentClass::classify_node(sema, &node)? {
                        // It's better for us to fall back to the keyword hover here,
                        // rendering poll is very confusing
                        IdentClass::Operator(OperatorClass::Await(_)) => None,

                        IdentClass::NameRefClass(NameRefClass::ExternCrateShorthand {
                            decl,
                            ..
                        }) => Some(vec![(Definition::ExternCrateDecl(decl), node)]),

                        class => Some(
                            class
                                .definitions()
                                .into_iter()
                                .zip(iter::repeat(node))
                                .collect::<Vec<_>>(),
                        ),
                    }
                })
                .flatten()
                .unique_by(|&(def, _)| def)
                .map(|(def, node)| hover_for_definition(sema, file_id, def, &node, config))
                .reduce(|mut acc: HoverResult, HoverResult { markup, actions }| {
                    acc.actions.extend(actions);
                    acc.markup = Markup::from(format!("{}\n---\n{markup}", acc.markup));
                    acc
                })
        })
        // try keywords
        .or_else(|| descended().find_map(|token| render::keyword(sema, config, token)))
        // try _ hovers
        .or_else(|| descended().find_map(|token| render::underscore(sema, config, token)))
        // try rest pattern hover
        .or_else(|| {
            descended().find_map(|token| {
                if token.kind() != DOT2 {
                    return None;
                }

                let rest_pat = token.parent().and_then(ast::RestPat::cast)?;
                let record_pat_field_list =
                    rest_pat.syntax().parent().and_then(ast::RecordPatFieldList::cast)?;

                let record_pat =
                    record_pat_field_list.syntax().parent().and_then(ast::RecordPat::cast)?;

                Some(render::struct_rest_pat(sema, config, &record_pat))
            })
        })
        // try () call hovers
        .or_else(|| {
            descended().find_map(|token| {
                if token.kind() != T!['('] && token.kind() != T![')'] {
                    return None;
                }
                let arg_list = token.parent().and_then(ast::ArgList::cast)?.syntax().parent()?;
                let call_expr = syntax::match_ast! {
                    match arg_list {
                        ast::CallExpr(expr) => expr.into(),
                        ast::MethodCallExpr(expr) => expr.into(),
                        _ => return None,
                    }
                };
                render::type_info_of(sema, config, &Either::Left(call_expr))
            })
        })
        // try closure
        .or_else(|| {
            descended().find_map(|token| {
                if token.kind() != T![|] {
                    return None;
                }
                let c = token.parent().and_then(|x| x.parent()).and_then(ast::ClosureExpr::cast)?;
                render::closure_expr(sema, config, c)
            })
        })
        // tokens
        .or_else(|| {
            let mut res = HoverResult::default();
            match_ast! {
                match original_token {
                    ast::String(string) => {
                        res.markup = Markup::fenced_block_text(format_args!("{}", string.value()?));
                    },
                    ast::ByteString(string) => {
                        res.markup = Markup::fenced_block_text(format_args!("{:?}", string.value()?));
                    },
                    ast::CString(string) => {
                        let val = string.value()?;
                        res.markup = Markup::fenced_block_text(format_args!("{}", std::str::from_utf8(val.as_ref()).ok()?));
                    },
                    ast::Char(char) => {
                        let mut res = HoverResult::default();
                        res.markup = Markup::fenced_block_text(format_args!("{}", char.value()?));
                    },
                    ast::Byte(byte) => {
                        res.markup = Markup::fenced_block_text(format_args!("0x{:X}", byte.value()?));
                    },
                    ast::FloatNumber(num) => {
                        res.markup = if num.suffix() == Some("f32") {
                            match num.value_f32() {
                                Ok(num) => {
                                    Markup::fenced_block_text(format_args!("{num} (bits: 0x{:X})", num.to_bits()))
                                },
                                Err(e) => {
                                    Markup::fenced_block_text(format_args!("{e}"))
                                },
                            }
                        } else {
                            match num.value() {
                                Ok(num) => {
                                    Markup::fenced_block_text(format_args!("{num} (bits: 0x{:X})", num.to_bits()))
                                },
                                Err(e) => {
                                    Markup::fenced_block_text(format_args!("{e}"))
                                },
                            }
                        };
                    },
                    ast::IntNumber(num) => {
                        res.markup = match num.value() {
                            Ok(num) => {
                                Markup::fenced_block_text(format_args!("{num} (0x{num:X}|0b{num:b})"))
                            },
                            Err(e) => {
                                Markup::fenced_block_text(format_args!("{e}"))
                            },
                        };
                    },
                    _ => return None
                }
            }
            Some(res)
        });

    result.map(|mut res: HoverResult| {
        res.actions = dedupe_or_merge_hover_actions(res.actions);
        RangeInfo::new(original_token.text_range(), res)
    })
}

fn hover_ranged(
    sema: &Semantics<'_, RootDatabase>,
    FileRange { range, .. }: FileRange,
    file: SyntaxNode,
    config: &HoverConfig,
) -> Option<RangeInfo<HoverResult>> {
    // FIXME: make this work in attributes
    let expr_or_pat = file
        .covering_element(range)
        .ancestors()
        .take_while(|it| ast::MacroCall::can_cast(it.kind()) || !ast::Item::can_cast(it.kind()))
        .find_map(Either::<ast::Expr, ast::Pat>::cast)?;
    let res = match &expr_or_pat {
        Either::Left(ast::Expr::TryExpr(try_expr)) => render::try_expr(sema, config, try_expr),
        Either::Left(ast::Expr::PrefixExpr(prefix_expr))
            if prefix_expr.op_kind() == Some(ast::UnaryOp::Deref) =>
        {
            render::deref_expr(sema, config, prefix_expr)
        }
        _ => None,
    };
    let res = res.or_else(|| render::type_info_of(sema, config, &expr_or_pat));
    res.map(|it| {
        let range = match expr_or_pat {
            Either::Left(it) => it.syntax().text_range(),
            Either::Right(it) => it.syntax().text_range(),
        };
        RangeInfo::new(range, it)
    })
}

// FIXME: Why is this pub(crate)?
pub(crate) fn hover_for_definition(
    sema: &Semantics<'_, RootDatabase>,
    file_id: FileId,
    def: Definition,
    scope_node: &SyntaxNode,
    config: &HoverConfig,
) -> HoverResult {
    let famous_defs = match &def {
        Definition::BuiltinType(_) => sema.scope(scope_node).map(|it| FamousDefs(sema, it.krate())),
        _ => None,
    };

    let db = sema.db;
    let def_ty = match def {
        Definition::Local(it) => Some(it.ty(db)),
        Definition::GenericParam(hir::GenericParam::ConstParam(it)) => Some(it.ty(db)),
        Definition::GenericParam(hir::GenericParam::TypeParam(it)) => Some(it.ty(db)),
        Definition::Field(field) => Some(field.ty(db)),
        Definition::TupleField(it) => Some(it.ty(db)),
        Definition::Function(it) => Some(it.ty(db)),
        Definition::Adt(it) => Some(it.ty(db)),
        Definition::Const(it) => Some(it.ty(db)),
        Definition::Static(it) => Some(it.ty(db)),
        Definition::TypeAlias(it) => Some(it.ty(db)),
        Definition::BuiltinType(it) => Some(it.ty(db)),
        _ => None,
    };
    let notable_traits = def_ty.map(|ty| notable_traits(db, &ty)).unwrap_or_default();

    let markup = render::definition(sema.db, def, famous_defs.as_ref(), &notable_traits, config);
    HoverResult {
        markup: render::process_markup(sema.db, def, &markup, config),
        actions: [
            show_implementations_action(sema.db, def),
            show_fn_references_action(sema.db, def),
            runnable_action(sema, def, file_id),
            goto_type_action_for_def(sema.db, def, &notable_traits),
        ]
        .into_iter()
        .flatten()
        .collect(),
    }
}

fn notable_traits(
    db: &RootDatabase,
    ty: &hir::Type,
) -> Vec<(hir::Trait, Vec<(Option<hir::Type>, hir::Name)>)> {
    db.notable_traits_in_deps(ty.krate(db).into())
        .iter()
        .flat_map(|it| &**it)
        .filter_map(move |&trait_| {
            let trait_ = trait_.into();
            ty.impls_trait(db, trait_, &[]).then(|| {
                (
                    trait_,
                    trait_
                        .items(db)
                        .into_iter()
                        .filter_map(hir::AssocItem::as_type_alias)
                        .map(|alias| {
                            (ty.normalize_trait_assoc_type(db, &[], alias), alias.name(db))
                        })
                        .collect::<Vec<_>>(),
                )
            })
        })
        .collect::<Vec<_>>()
}

fn show_implementations_action(db: &RootDatabase, def: Definition) -> Option<HoverAction> {
    fn to_action(nav_target: NavigationTarget) -> HoverAction {
        HoverAction::Implementation(FilePosition {
            file_id: nav_target.file_id,
            offset: nav_target.focus_or_full_range().start(),
        })
    }

    let adt = match def {
        Definition::Trait(it) => {
            return it.try_to_nav(db).map(UpmappingResult::call_site).map(to_action)
        }
        Definition::Adt(it) => Some(it),
        Definition::SelfType(it) => it.self_ty(db).as_adt(),
        _ => None,
    }?;
    adt.try_to_nav(db).map(UpmappingResult::call_site).map(to_action)
}

fn show_fn_references_action(db: &RootDatabase, def: Definition) -> Option<HoverAction> {
    match def {
        Definition::Function(it) => {
            it.try_to_nav(db).map(UpmappingResult::call_site).map(|nav_target| {
                HoverAction::Reference(FilePosition {
                    file_id: nav_target.file_id,
                    offset: nav_target.focus_or_full_range().start(),
                })
            })
        }
        _ => None,
    }
}

fn runnable_action(
    sema: &hir::Semantics<'_, RootDatabase>,
    def: Definition,
    file_id: FileId,
) -> Option<HoverAction> {
    match def {
        Definition::Module(it) => runnable_mod(sema, it).map(HoverAction::Runnable),
        Definition::Function(func) => {
            let src = func.source(sema.db)?;
            if src.file_id != file_id.into() {
                cov_mark::hit!(hover_macro_generated_struct_fn_doc_comment);
                cov_mark::hit!(hover_macro_generated_struct_fn_doc_attr);
                return None;
            }

            runnable_fn(sema, func).map(HoverAction::Runnable)
        }
        _ => None,
    }
}

fn goto_type_action_for_def(
    db: &RootDatabase,
    def: Definition,
    notable_traits: &[(hir::Trait, Vec<(Option<hir::Type>, hir::Name)>)],
) -> Option<HoverAction> {
    let mut targets: Vec<hir::ModuleDef> = Vec::new();
    let mut push_new_def = |item: hir::ModuleDef| {
        if !targets.contains(&item) {
            targets.push(item);
        }
    };

    for &(trait_, ref assocs) in notable_traits {
        push_new_def(trait_.into());
        assocs.iter().filter_map(|(ty, _)| ty.as_ref()).for_each(|ty| {
            walk_and_push_ty(db, ty, &mut push_new_def);
        });
    }

    if let Definition::GenericParam(hir::GenericParam::TypeParam(it)) = def {
        let krate = it.module(db).krate();
        let sized_trait =
            db.lang_item(krate.into(), LangItem::Sized).and_then(|lang_item| lang_item.as_trait());

        it.trait_bounds(db)
            .into_iter()
            .filter(|&it| Some(it.into()) != sized_trait)
            .for_each(|it| push_new_def(it.into()));
    } else {
        let ty = match def {
            Definition::Local(it) => it.ty(db),
            Definition::GenericParam(hir::GenericParam::ConstParam(it)) => it.ty(db),
            Definition::Field(field) => field.ty(db),
            Definition::Function(function) => function.ret_type(db),
            _ => return HoverAction::goto_type_from_targets(db, targets),
        };

        walk_and_push_ty(db, &ty, &mut push_new_def);
    }

    HoverAction::goto_type_from_targets(db, targets)
}

fn walk_and_push_ty(
    db: &RootDatabase,
    ty: &hir::Type,
    push_new_def: &mut dyn FnMut(hir::ModuleDef),
) {
    ty.walk(db, |t| {
        if let Some(adt) = t.as_adt() {
            push_new_def(adt.into());
        } else if let Some(trait_) = t.as_dyn_trait() {
            push_new_def(trait_.into());
        } else if let Some(traits) = t.as_impl_traits(db) {
            traits.for_each(|it| push_new_def(it.into()));
        } else if let Some(trait_) = t.as_associated_type_parent_trait(db) {
            push_new_def(trait_.into());
        }
    });
}

fn dedupe_or_merge_hover_actions(actions: Vec<HoverAction>) -> Vec<HoverAction> {
    let mut deduped_actions = Vec::with_capacity(actions.len());
    let mut go_to_type_targets = FxIndexSet::default();

    let mut seen_implementation = false;
    let mut seen_reference = false;
    let mut seen_runnable = false;
    for action in actions {
        match action {
            HoverAction::GoToType(targets) => {
                go_to_type_targets.extend(targets);
            }
            HoverAction::Implementation(..) => {
                if !seen_implementation {
                    seen_implementation = true;
                    deduped_actions.push(action);
                }
            }
            HoverAction::Reference(..) => {
                if !seen_reference {
                    seen_reference = true;
                    deduped_actions.push(action);
                }
            }
            HoverAction::Runnable(..) => {
                if !seen_runnable {
                    seen_runnable = true;
                    deduped_actions.push(action);
                }
            }
        };
    }

    if !go_to_type_targets.is_empty() {
        deduped_actions.push(HoverAction::GoToType(
            go_to_type_targets.into_iter().sorted_by(|a, b| a.mod_path.cmp(&b.mod_path)).collect(),
        ));
    }

    deduped_actions
}

static JSON:&'static str = r#"{"map":{"primitive.isize.html#method.unchecked_shr":"‼️`self` **Bounded**:\n > _This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`._\n\n \n\n","os/fd/struct.BorrowedFd.html#method.borrow_raw":"‼️`fd` **Bounded**:\n > _The resource pointed to by `fd` must not have the value `-1`._\n\n \n‼️`fd` **SystemIO**:\n > _The resource pointed to by `fd` must remain open for the duration of the returned `BorrowedFd`._\n\n \n\n","any/trait.Any.html#method.downcast_ref_unchecked-1":"‼️`self` **Initialized**:\n > _The contained value must be of type `T`._\n\n \n\n","num/struct.NonZeroI8.html#method.new_unchecked":"‼️`n` **Bounded**:\n > _The value must not be zero._\n\n \n\n","boxed/struct.Box.html#method.assume_init":"‼️`self` **Initialized**:\n > _It is up to the caller to guarantee that the value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior._\n\n \n\n","primitive.pointer.html#method.byte_offset_from-1":"‼️`origin` **Allocated**:\n > __\n\n \n‼️`origin` **Dereferencable**:\n > _`origin` must be either in bounds or one byte past the end of the same allocated object._\n\n \n‼️`self` **Allocated**:\n > __\n\n \n‼️`self` **Bounded**:\n > _The distance between the pointers, in bytes, cannot overflow an `isize`._\n\n > _The distance between the pointers, in bytes, must be an exact multiple of the size of `T`._\n\n \n‼️`self` **Dereferencable**:\n > _`self` must be either in bounds or one byte past the end of the same allocated object._\n\n > _Both pointers must be derived from a pointer to the same object._\n\n \n‼️`self` **Layout**:\n > _This function panics if `T` is a Zero-Sized Type (ZST)._\n\n \n\n","ops/struct.RangeTo.html#method.get_unchecked":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","intrinsics/fn.write_bytes.html":"‼️`dst` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`dst` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`dst` **Layout**:\n > _`dst` must be properly aligned._\n\n \n‼️`dst` **Leaked**:\n > __\n\n \n‼️`dst` **Untyped**:\n > _Additionally, note that changing `dst` in this way can easily lead to undefined behavior (UB) later if the written bytes are not a valid representation of some `T`._\n\n \n\n","ops/struct.RangeFrom.html#method.get_unchecked_mut":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","primitive.pointer.html#method.write_bytes":"‼️`self` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned._\n\n \n‼️`self` **Leaked**:\n > __\n\n \n‼️`self` **Untyped**:\n > _Additionally, note that changing `self` in this way can easily lead to undefined behavior (UB) later if the written bytes are not a valid representation of some `T`._\n\n \n\n","ptr/struct.NonNull.html#method.sub_ptr":"‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Bounded**:\n > _The distance between the pointers, in bytes, cannot overflow an `isize`._\n\n > _The distance between the pointers, in bytes, must be an exact multiple of the size of `T`._\n\n > _The distance between the pointers must be non-negative (`self` >= `subtracted`)._\n\n \n‼️`self` **Dereferencable**:\n > _`self` must be either in bounds or one byte past the end of the same allocated object._\n\n > _Both pointers must be derived from a pointer to the same object._\n\n \n‼️`self` **Layout**:\n > _This function panics if `T` is a Zero-Sized Type (ZST)._\n\n \n‼️`subtracted` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`subtracted` **Dereferencable**:\n > _`subtracted` must be either in bounds or one byte past the end of the same allocated object._\n\n \n\n","primitive.slice.html#method.align_to":"‼️`retval` **Aliased**:\n > _It can turn a `*mut T` into an `&mut T`._\n\n > _It can extend a lifetime, or shorten an invariant lifetime._\n\n \n‼️`retval` **Initialized**:\n > _Both the argument and the result must be valid at their given type._\n\n \n‼️`retval` **Untyped**:\n > _It is therefore your responsibility to guarantee that every value passed to transmute is valid at both types `T` and `U`. Failing to uphold this condition may lead to unexpected and unstable compilation results._\n\n \n‼️`self` **Initialized**:\n > _Both the `T` and the `U` must be valid at their given type._\n\n > _To transmute the inner type of the contents of a container, you must make sure to not violate any of the container's invariants._\n\n \n‼️`self` **Layout**:\n > _Both types must have the same size._\n\n > _Note that source and destination are passed by-value, which means if `T` or `U` contain padding, that padding is not guaranteed to be preserved by transmute._\n\n > _This method has no purpose when either input element `T` or output element `U` are zero-sized and will return the original slice without splitting anything._\n\n > _When transmuting values that point elsewhere (such as pointers, references, boxes…), the caller has to ensure proper alignment of the pointed-to values._\n\n \n\n","primitive.pointer.html#method.byte_add":"‼️`self` **Allocated**:\n > __\n\n \n‼️`self` **Bounded**:\n > _The computed offset cannot exceed `isize::MAX` bytes._\n\n \n‼️`self` **Dereferencable**:\n > _Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object._\n\n \n\n","primitive.i32.html#method.unchecked_add":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self + rhs > i32::MAX` or `self + rhs < i32::MIN`._\n\n \n\n","ptr/struct.NonNull.html#method.copy_from_nonoverlapping":"‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n > _The region of memory beginning at `self` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `src` with the same size._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned._\n\n \n‼️`self` **Leaked**:\n > __\n\n \n‼️`src` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`src` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n > _The region of memory beginning at `self` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `src` with the same size._\n\n \n‼️`src` **DualOwned**:\n > _If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*src` can violate memory safety. Note that assigning to `*src` counts as a use because it will attempt to drop the value at `*src`._\n\n \n‼️`src` **Layout**:\n > _`src` must be properly aligned._\n\n \n‼️`src` **Untyped**:\n > _The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`._\n\n \n\n","io/struct.BorrowedCursor.html#method.as_mut":"‼️`self` **Initialized**:\n > _The caller must not uninitialize any bytes in the initialized portion of the cursor._\n\n \n\n","primitive.pointer.html#method.byte_offset-1":"‼️`self` **Allocated**:\n > __\n\n \n‼️`self` **Bounded**:\n > _The computed offset, in bytes, cannot overflow an `isize`._\n\n \n‼️`self` **Dereferencable**:\n > _Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object._\n\n \n\n","alloc/trait.GlobalAlloc.html#tymethod.alloc":"‼️`layout` **Layout**:\n > _`layout` has non-zero size._\n\n \n‼️`retval` **Freed**:\n > _Returning a null pointer indicates that either memory is exhausted._\n\n \n‼️`retval` **Untyped**:\n > _The allocated block of memory may or may not be initialized._\n\n \n\n","option/enum.Option.html#method.unwrap_unchecked":"‼️`self` **Unreachable**:\n > _Calling this method on `None` is undefined behavior._\n\n \n\n","num/struct.NonZeroI32.html#method.new_unchecked":"‼️`n` **Bounded**:\n > _The value must not be zero._\n\n \n\n","pin/struct.Pin.html#method.map_unchecked_mut":"‼️`retval` **Pinned**:\n > _The data you return will not move so long as the argument value does not move (for example, because it is one of the fields of that value), and also that you do not move out of the argument you receive to the interior function._\n\n \n\n","ptr/struct.NonNull.html#method.write_bytes":"‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned._\n\n \n‼️`self` **Leaked**:\n > __\n\n \n‼️`self` **Untyped**:\n > _Additionally, note that changing `self` in this way can easily lead to undefined behavior (UB) later if the written bytes are not a valid representation of some `T`._\n\n \n\n","primitive.pointer.html#method.read":"‼️`retval` **DualOwned**:\n > _If `T` is not `Copy`, using both the returned value and the value at `self` can violate memory safety. Note that assigning to `self` counts as a use because it will attempt to drop the value at `self`._\n\n \n‼️`self` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Initialized**:\n > _`self` must point to a properly initialized value of type `T`._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned._\n\n \n\n","io/struct.BorrowedCursor.html#method.set_init":"‼️`self` **Initialized**:\n > _The caller must ensure that the first `n` bytes of the buffer have already been initialized._\n\n \n\n","primitive.usize.html#method.unchecked_mul":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self * rhs > usize::MAX` or `self * rhs < usize::MIN`._\n\n \n\n","num/struct.NonZeroU64.html#method.new_unchecked":"‼️`n` **Bounded**:\n > _The value must not be zero._\n\n \n\n","any/trait.Any.html#method.downcast_mut_unchecked-2":"‼️`self` **Initialized**:\n > _The contained value must be of type `T`._\n\n \n\n","ptr/fn.read_unaligned.html":"‼️`retval` **DualOwned**:\n > _If `T` is not `Copy`, using both the returned value and the value at `*src` can violate memory safety. Note that assigning to `*src` counts as a use because it will attempt to drop the value at `*src`._\n\n \n‼️`src` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`src` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`src` **Initialized**:\n > _`src` must point to a properly initialized value of type `T`._\n\n \n\n","ptr/struct.NonNull.html#method.add":"‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Bounded**:\n > _The computed offset cannot exceed `isize::MAX` bytes._\n\n \n‼️`self` **Dereferencable**:\n > _Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object._\n\n \n\n","mem/union.MaybeUninit.html#method.assume_init_drop":"‼️`self` **Freed**:\n > _Drops the contained value in place._\n\n \n‼️`self` **Initialized**:\n > _It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized state._\n\n > _All additional invariants of the type `T` must be satisfied, as the `Drop` implementation of `T` (or its members) may rely on this._\n\n \n\n","primitive.str.html#method.as_bytes_mut":"‼️`self` **Initialized**:\n > _The caller must ensure that the content of the slice is valid UTF-8 before the borrow ends and the underlying `str` is used._\n\n \n\n","primitive.isize.html#method.unchecked_sub":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self - rhs > isize::MAX` or `self - rhs < isize::MIN`._\n\n \n\n","primitive.pointer.html#method.offset_from-1":"‼️`origin` **Allocated**:\n > __\n\n \n‼️`origin` **Dereferencable**:\n > _`origin` must be either in bounds or one byte past the end of the same allocated object._\n\n \n‼️`self` **Allocated**:\n > __\n\n \n‼️`self` **Bounded**:\n > _The distance between the pointers, in bytes, cannot overflow an `isize`._\n\n > _The distance between the pointers, in bytes, must be an exact multiple of the size of `T`._\n\n \n‼️`self` **Dereferencable**:\n > _`self` must be either in bounds or one byte past the end of the same allocated object._\n\n > _Both pointers must be derived from a pointer to the same object._\n\n \n‼️`self` **Layout**:\n > _This function panics if `T` is a Zero-Sized Type (ZST)._\n\n \n\n","mem/fn.size_of_val_raw.html":"‼️`val` **Bounded**:\n > _If the unsized tail of `T` is a slice, then the length of the slice tail must be an initialized integer, and the size of the entire value (dynamic tail length + statically sized prefix) must fit in `isize`._\n\n > _If the unsized tail of `T` is a trait object, then the vtable part of the pointer must point to a valid vtable for the type `T` acquired by an unsizing coercion, and the size of the entire value (dynamic tail length + statically sized prefix) must fit in `isize`._\n\n \n‼️`val` **Layout**:\n > _If the unsized tail of `T` is a slice, then the length of the slice tail must be an initialized integer, and the size of the entire value (dynamic tail length + statically sized prefix) must fit in `isize`._\n\n > _If the unsized tail of `T` is a trait object, then the vtable part of the pointer must point to a valid vtable for the type `T` acquired by an unsizing coercion, and the size of the entire value (dynamic tail length + statically sized prefix) must fit in `isize`._\n\n \n\n","ops/struct.RangeToInclusive.html#method.get_unchecked_mut":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","ops/struct.RangeTo.html#method.get_unchecked_mut-1":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","result/enum.Result.html#method.unwrap_err_unchecked":"‼️`self` **Unreachable**:\n > _Calling this method on an `Ok` is undefined behavior._\n\n \n\n","ptr/fn.read.html":"‼️`retval` **DualOwned**:\n > _If `T` is not `Copy`, using both the returned value and the value at `*src` can violate memory safety. Note that assigning to `*src` counts as a use because it will attempt to drop the value at `*src`._\n\n \n‼️`src` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`src` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`src` **Initialized**:\n > _`src` must point to a properly initialized value of type `T`._\n\n \n‼️`src` **Layout**:\n > _`src` must be properly aligned._\n\n \n\n","num/struct.NonZeroU128.html#method.new_unchecked":"‼️`n` **Bounded**:\n > _The value must not be zero._\n\n \n\n","ptr/fn.write_unaligned.html":"‼️`dst` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`dst` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`dst` **Leaked**:\n > _This is safe, but it could leak allocations or resources, so care should be taken not to overwrite an object that should be dropped._\n\n \n\n","primitive.f32.html#method.to_int_unchecked":"‼️`self` **Bounded**:\n > _The value must not be `NaN`._\n\n > _The value must not be infinite._\n\n > _The value must be representable in the return type `Int`, after truncating off its fractional part._\n\n \n\n","ptr/struct.NonNull.html#method.write":"‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned._\n\n \n‼️`self` **Leaked**:\n > _This is safe, but it could leak allocations or resources, so care should be taken not to overwrite an object that should be dropped._\n\n \n\n","alloc/struct.System.html#method.dealloc":"‼️`layout` **Layout**:\n > _`layout` must be the same layout that was used to allocate that block of memory._\n\n \n‼️`ptr` **Allocated**:\n > _`ptr` must denote a block of memory currently allocated via this allocator._\n\n \n\n","ptr/struct.NonNull.html#method.byte_sub":"‼️`self` **Bounded**:\n > _The computed offset cannot exceed `isize::MAX` bytes._\n\n \n‼️`self` **Dereferencable**:\n > _Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object._\n\n \n\n","ptr/struct.NonNull.html#method.offset_from":"‼️`origin` **Dereferencable**:\n > _`origin` must be either in bounds or one byte past the end of the same allocated object._\n\n \n‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Bounded**:\n > _The distance between the pointers, in bytes, cannot overflow an `isize`._\n\n > _The distance between the pointers, in bytes, must be an exact multiple of the size of `T`._\n\n \n‼️`self` **Dereferencable**:\n > _`self` must be either in bounds or one byte past the end of the same allocated object._\n\n > _Both pointers must be derived from a pointer to the same object._\n\n \n‼️`self` **Layout**:\n > _This function panics if `T` is a Zero-Sized Type (ZST)._\n\n \n\n","sync/struct.Arc.html#method.from_raw_in":"‼️`ptr` **Allocated**:\n > _The raw pointer must point to a block of memory allocated by `alloc` in the provided allocator._\n\n \n‼️`ptr` **Initialized**:\n > _The raw pointer must have been previously returned by a call to `Arc<U>::into_raw`._\n\n > _Note that if `U` is not `T` but has the same size and alignment, this is basically like transmuting references of different types._\n\n \n‼️`ptr` **Layout**:\n > _`Arc<U>::into_raw` where `U` must have the same size and alignment as `T`._\n\n \n‼️`retval` **DualOwned**:\n > _The user of `from_raw` has to make sure a specific value of `T` is only dropped once._\n\n \n\n","primitive.char.html#method.backward_unchecked":"‼️`start` **Bounded**:\n > _`start` - `count` may overflow the range of values supported by `char::MIN`._\n\n \n\n","num/struct.NonZeroI64.html#method.new_unchecked":"‼️`n` **Bounded**:\n > _The value must not be zero._\n\n \n\n","primitive.slice.html#method.align_to_mut":"‼️`retval` **Aliased**:\n > _It can turn a `*mut T` into an `&mut T`._\n\n > _It can extend a lifetime, or shorten an invariant lifetime._\n\n \n‼️`retval` **Initialized**:\n > _Both the argument and the result must be valid at their given type._\n\n \n‼️`retval` **Untyped**:\n > _It is therefore your responsibility to guarantee that every value passed to transmute is valid at both types `T` and `U`. Failing to uphold this condition may lead to unexpected and unstable compilation results._\n\n \n‼️`self` **Initialized**:\n > _Both the `T` and the `U` must be valid at their given type._\n\n > _To transmute the inner type of the contents of a container, you must make sure to not violate any of the container's invariants._\n\n \n‼️`self` **Layout**:\n > _Both types must have the same size._\n\n > _Note that source and destination are passed by-value, which means if `T` or `U` contain padding, that padding is not guaranteed to be preserved by transmute._\n\n > _This method has no purpose when either input element `T` or output element `U` are zero-sized and will return the original slice without splitting anything._\n\n > _When transmuting values that point elsewhere (such as pointers, references, boxes…), the caller has to ensure proper alignment of the pointed-to values._\n\n \n\n","intrinsics/fn.const_deallocate.html":"‼️`align` **Bounded**:\n > _`align` argument must be a power of two._\n\n \n\n","primitive.pointer.html#method.get_unchecked_mut":"‼️`index` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting pointer is not used._\n\n \n‼️`self` **Dereferencable**:\n > _When `self` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","alloc/struct.System.html#method.alloc":"‼️`layout` **Layout**:\n > _`layout` has non-zero size._\n\n \n‼️`retval` **Freed**:\n > _Returning a null pointer indicates that either memory is exhausted._\n\n \n‼️`retval` **Untyped**:\n > _The allocated block of memory may or may not be initialized._\n\n \n\n","mem/union.MaybeUninit.html#method.array_assume_init":"‼️`array` **Initialized**:\n > _It is up to the caller to guarantee that all elements of the array are in an initialized state._\n\n \n\n","vec/struct.Vec.html#method.from_raw_parts":"‼️`capacity` **Bounded**:\n > _The size of `T` times the `capacity` (ie. the allocated size in bytes) needs to be the same size as the pointer was allocated with._\n\n > _`capacity` needs to be the capacity that the pointer was allocated with._\n\n > _`length` needs to be less than or equal to `capacity`._\n\n \n‼️`ptr` **Allocated**:\n > _`ptr` must have been allocated using the global allocator, such as via the `alloc::alloc` function._\n\n \n‼️`ptr` **Bounded**:\n > _The allocated size in bytes must be no larger than `isize::MAX`._\n\n \n‼️`ptr` **Initialized**:\n > _The first `length` values must be properly initialized values of type `T`._\n\n \n‼️`ptr` **Layout**:\n > _`T` needs to have the same alignment as what `ptr` was allocated with._\n\n \n‼️`retval` **DualOwned**:\n > _The ownership of `ptr` is effectively transferred to the `Vec<T>` which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function._\n\n \n\n","ops/struct.RangeTo.html#method.get_unchecked-1":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","primitive.i64.html#method.unchecked_add":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self + rhs > i64::MAX` or `self + rhs < i64::MIN`._\n\n \n\n","task/struct.Waker.html#method.from_raw":"‼️`waker` **Thread**:\n > _These functions must all be thread-safe (even though `RawWaker` is `!Send + !Sync`) because `Waker` is `Send + Sync`, and thus wakers may be moved to arbitrary threads or invoked by `&` reference._\n\n \n\n","ptr/struct.NonNull.html#method.byte_offset_from":"‼️`origin` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`origin` **Dereferencable**:\n > _`origin` must be either in bounds or one byte past the end of the same allocated object._\n\n \n‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Bounded**:\n > _The distance between the pointers, in bytes, cannot overflow an `isize`._\n\n > _The distance between the pointers, in bytes, must be an exact multiple of the size of `T`._\n\n \n‼️`self` **Dereferencable**:\n > _`self` must be either in bounds or one byte past the end of the same allocated object._\n\n > _Both pointers must be derived from a pointer to the same object._\n\n \n‼️`self` **Layout**:\n > _This function panics if `T` is a Zero-Sized Type (ZST)._\n\n \n\n","primitive.f64.html#method.to_int_unchecked":"‼️`self` **Bounded**:\n > _The value must not be `NaN`._\n\n > _The value must not be infinite._\n\n > _The value must be representable in the return type `Int`, after truncating off its fractional part._\n\n \n\n","ptr/struct.NonNull.html#method.read":"‼️`retval` **DualOwned**:\n > _If `T` is not `Copy`, using both the returned value and the value at `self` can violate memory safety. Note that assigning to `self` counts as a use because it will attempt to drop the value at `self`._\n\n \n‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Initialized**:\n > _`self` must point to a properly initialized value of type `T`._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned._\n\n \n\n","primitive.u16.html#method.unchecked_mul":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self * rhs > u16::MAX` or `self * rhs < u16::MIN`._\n\n \n\n","pin/struct.Pin.html#method.new_unchecked":"‼️`retval` **Pinned**:\n > _If the constructed `Pin<P>` does not guarantee that the data `P` points to is pinned, that is a violation of the API contract and may lead to undefined behavior in later (safe) operations._\n\n > _`P::Deref` and `P::DerefMut` implementations must not move out of their self arguments: `Pin::as_mut` and `Pin::as_ref` will call `DerefMut::deref_mut` and `Deref::deref` on the pinned pointer and expect these methods to uphold the pinning invariants._\n\n > _The reference `P` dereferences to will not be moved out of again; in particular, it must not be possible to obtain a `&mut P::Target` and then move out of that reference._\n\n \n\n","primitive.i128.html#method.unchecked_shl":"‼️`self` **Bounded**:\n > _This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`._\n\n \n\n","primitive.usize.html#method.forward_unchecked":"‼️`start` **Bounded**:\n > _`start` + `count` may overflow the range of values supported by `usize::MAX`._\n\n \n\n","sync/struct.Arc.html#method.from_raw":"‼️`ptr` **Allocated**:\n > _The raw pointer must point to a block of memory allocated by the global allocator._\n\n \n‼️`ptr` **Initialized**:\n > _The raw pointer must have been previously returned by a call to `Arc<U>::into_raw`._\n\n > _Note that if `U` is not `T` but has the same size and alignment, this is basically like transmuting references of different types._\n\n \n‼️`ptr` **Layout**:\n > _`Arc<U>::into_raw` where `U` must have the same size and alignment as `T`._\n\n \n‼️`retval` **DualOwned**:\n > _The user of `from_raw` has to make sure a specific value of `T` is only dropped once._\n\n \n\n","result/enum.Result.html#method.unwrap_unchecked":"‼️`self` **Unreachable**:\n > _Calling this method on an `Err` is undefined behavior._\n\n \n\n","mem/struct.ManuallyDrop.html#method.take":"‼️`retval` **DualOwned**:\n > _This function semantically moves out the contained value without preventing further usage, leaving the state of this container unchanged. It is your responsibility to ensure that this `ManuallyDrop` is not used again._\n\n \n\n","string/struct.String.html#method.from_raw_parts":"‼️`buf` **Allocated**:\n > _The memory at `buf` needs to have been previously allocated by the same allocator the standard library uses._\n\n \n‼️`buf` **Initialized**:\n > _The first length bytes at `buf` need to be valid UTF-8._\n\n \n‼️`buf` **Layout**:\n > _The memory at buf is required alignment of exactly 1._\n\n \n‼️`capacity` **Bounded**:\n > _`capacity` needs to be the correct value._\n\n \n‼️`length` **Bounded**:\n > _`length` needs to be less than or equal to `capacity`._\n\n \n‼️`retval` **DualOwned**:\n > _The ownership of `buf` is effectively transferred to the `String` which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function._\n\n \n\n","primitive.u128.html#method.backward_unchecked":"‼️`start` **Bounded**:\n > _`start` - `count` may overflow the range of values supported by `u128::MIN`._\n\n \n\n","ptr/struct.NonNull.html#method.copy_from":"‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned._\n\n \n‼️`self` **Leaked**:\n > __\n\n \n‼️`src` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`src` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`src` **DualOwned**:\n > _If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*src` can violate memory safety. Note that assigning to `*src` counts as a use because it will attempt to drop the value at `*src`._\n\n \n‼️`src` **Layout**:\n > _`src` must be properly aligned._\n\n \n‼️`src` **Untyped**:\n > _The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`._\n\n \n\n","sync/struct.Weak.html#method.from_raw_in":"‼️`ptr` **Allocated**:\n > _`ptr` must point to a block of memory allocated by `alloc` in the provided allocator._\n\n \n‼️`ptr` **Initialized**:\n > _The pointer must have originated from the `Weak::into_raw` and must still own its potential weak reference._\n\n \n‼️`retval` **DualOwned**:\n > _It takes ownership of one weak reference. This can be used to deallocate the weak count by dropping the `Weak<T>`._\n\n \n\n","intrinsics/fn.copy_nonoverlapping.html":"‼️`dst` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`dst` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n > _The region of memory beginning at `src` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `dst` with the same size._\n\n \n‼️`dst` **DualOwned**:\n > _If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*dst` can violate memory safety. Note that assigning to `*dst` counts as a use because it will attempt to drop the value at `*dst`._\n\n \n‼️`dst` **Layout**:\n > _`dst` must be properly aligned._\n\n \n‼️`dst` **Leaked**:\n > __\n\n \n‼️`dst` **Untyped**:\n > _The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`._\n\n \n‼️`src` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`src` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n > _The region of memory beginning at `src` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `dst` with the same size._\n\n \n‼️`src` **Layout**:\n > _`src` must be properly aligned._\n\n \n\n","primitive.slice.html#method.split_at_mut_unchecked":"‼️`mid` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used. The caller has to ensure that `0 <= mid <= self.len()`._\n\n \n\n","string/struct.String.html#method.as_mut_vec":"‼️`self` **Untyped**:\n > _The returned &mut Vec allows writing bytes which are not valid UTF-8._\n\n \n\n","ptr/fn.write.html":"‼️`dst` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`dst` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`dst` **Layout**:\n > _`dst` must be properly aligned._\n\n \n‼️`dst` **Leaked**:\n > _This is safe, but it could leak allocations or resources, so care should be taken not to overwrite an object that should be dropped._\n\n \n\n","primitive.u128.html#method.unchecked_sub":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self - rhs > u128::MAX` or `self - rhs < u128::MIN`._\n\n \n\n","primitive.u32.html#method.backward_unchecked":"‼️`start` **Bounded**:\n > _`start` - `count` may overflow the range of values supported by `u32::MIN`._\n\n \n\n","primitive.i16.html#method.unchecked_shr":"‼️`self` **Bounded**:\n > _This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`._\n\n \n\n","rc/struct.Rc.html#method.decrement_strong_count_in":"‼️`ptr` **Allocated**:\n > _`ptr` must point to a block of memory allocated by allocated by `alloc` in the provided allocator._\n\n \n‼️`ptr` **Bounded**:\n > _The associated `Rc` instance must be valid (i.e. the strong count must be at least 1) when invoking this method._\n\n \n‼️`ptr` **Freed**:\n > _This method can be used to release the final `Rc` and backing storage, but should not be called after the final `Rc` has been released._\n\n \n‼️`ptr` **Initialized**:\n > _The pointer must have been obtained through `Rc::into_raw`._\n\n \n\n","os/unix/net/struct.UnixDatagram.html#method.from_raw_fd":"‼️`fd` **SystemIO**:\n > _The `fd` passed in must be an owned file descriptor; in particular, it must be open._\n\n \n\n","primitive.str.html#method.get_unchecked_mut":"‼️`i` **Bounded**:\n > _The starting index must not exceed the ending index._\n\n > _Indexes must be within bounds of the original slice._\n\n \n‼️`i` **Initialized**:\n > _Indexes must lie on UTF-8 sequence boundaries._\n\n \n\n","rc/struct.Weak.html#method.from_raw_in":"‼️`ptr` **Allocated**:\n > _`ptr` must point to a block of memory allocated by `alloc` in the provided allocator._\n\n \n‼️`ptr` **Initialized**:\n > _The pointer must have originated from the `Weak::into_raw` and must still own its potential weak reference._\n\n \n‼️`retval` **DualOwned**:\n > _It takes ownership of one weak reference. This can be used to deallocate the weak count by dropping the `Weak<T>`._\n\n \n\n","primitive.pointer.html#method.as_ref-1":"‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n‼️`self` **Allocated**:\n > _Either the pointer is null or all of the following is true._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Initialized**:\n > _The pointer must point to an initialized instance of `T`._\n\n \n‼️`self` **Layout**:\n > _The pointer must be properly aligned._\n\n \n\n","rc/struct.Rc.html#method.increment_strong_count":"‼️`ptr` **Allocated**:\n > _`ptr` must point to a block of memory allocated by the global allocator._\n\n \n‼️`ptr` **Bounded**:\n > _The associated `Rc` instance must be valid (i.e. the strong count must be at least 1) for the duration of this method._\n\n \n‼️`ptr` **Initialized**:\n > _The pointer must have been obtained through `Rc::into_raw`._\n\n \n\n","primitive.slice.html#method.get_many_unchecked_mut":"‼️`index` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n\n","ops/struct.RangeFull.html#method.get_unchecked_mut":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","primitive.pointer.html#method.copy_to_nonoverlapping":"‼️`dest` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`dest` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n > _The region of memory beginning at `self` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `dest` with the same size._\n\n \n‼️`dest` **DualOwned**:\n > _If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*dest` can violate memory safety. Note that assigning to `*dest` counts as a use because it will attempt to drop the value at `*dest`._\n\n \n‼️`dest` **Layout**:\n > _`dest` must be properly aligned._\n\n \n‼️`dest` **Leaked**:\n > __\n\n \n‼️`dest` **Untyped**:\n > _The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`._\n\n \n‼️`self` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n > _The region of memory beginning at `self` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `dest` with the same size._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned._\n\n \n\n","primitive.pointer.html#method.as_uninit_slice-1":"‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n‼️`self` **Allocated**:\n > _Either the pointer is null or all of the following is true._\n\n \n‼️`self` **Bounded**:\n > _The total size `ptr.len() * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`._\n\n \n‼️`self` **Dereferencable**:\n > _The entire memory range of this slice (`ptr.len() * mem::size_of::<T>()` bytes) must be contained within a single allocated object! Slices can never span across multiple allocated objects._\n\n \n‼️`self` **Layout**:\n > _The pointer must be aligned even for zero-length slices._\n\n \n\n","intrinsics/fn.const_allocate.html":"‼️`align` **Bounded**:\n > _`align` argument must be a power of two._\n\n \n\n","pin/struct.Pin.html#method.into_inner_unchecked":"‼️`retval` **Pinned**:\n > _You will continue to treat the pointer `P` as pinned after you call this function, so that the invariants on the Pin type can be upheld. If the code using the resulting `P` does not continue to maintain the pinning invariants that is a violation of the API contract and may lead to undefined behavior in later (safe) operations._\n\n \n\n","primitive.tuple.html#method.get_unchecked_mut":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","primitive.u64.html#method.unchecked_add":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self + rhs > u64::MAX` or `self + rhs < u64::MIN`._\n\n \n\n","primitive.pointer.html#method.add-1":"‼️`self` **Allocated**:\n > __\n\n \n‼️`self` **Bounded**:\n > _The computed offset cannot exceed `isize::MAX` bytes._\n\n \n‼️`self` **Dereferencable**:\n > _Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object._\n\n \n\n","vec/struct.Vec.html#method.from_raw_parts_in":"‼️`capacity` **Bounded**:\n > _The size of `T` times the `capacity` (ie. the allocated size in bytes) needs to be the same size as the pointer was allocated with._\n\n > _`capacity` needs to be the capacity that the pointer was allocated with._\n\n > _`length` needs to be less than or equal to `capacity`._\n\n \n‼️`ptr` **Allocated**:\n > _`ptr` must be currently allocated via the given allocator `alloc`._\n\n \n‼️`ptr` **Bounded**:\n > _The allocated size in bytes must be no larger than `isize::MAX`._\n\n \n‼️`ptr` **Initialized**:\n > _The first `length` values must be properly initialized values of type `T`._\n\n \n‼️`ptr` **Layout**:\n > _`T` needs to have the same alignment as what `ptr` was allocated with._\n\n \n‼️`retval` **DualOwned**:\n > _The ownership of `ptr` is effectively transferred to the `Vec<T>` which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function._\n\n \n\n","sync/struct.Arc.html#method.increment_strong_count_in":"‼️`ptr` **Allocated**:\n > _`ptr` must point to a block of memory allocated by allocated by `alloc` in the provided allocator._\n\n \n‼️`ptr` **Bounded**:\n > _The associated `Arc` instance must be valid (i.e. the strong count must be at least 1) for the duration of this method._\n\n \n‼️`ptr` **Initialized**:\n > _The pointer must have been obtained through `Arc::into_raw`._\n\n \n\n","slice/fn.from_ptr_range.html#":"‼️`range` **Allocated**:\n > _The `start` pointer of the range must be non-null even for zero-length slices._\n\n > _The `end` pointer of the range must be non-null even for zero-length slices._\n\n \n‼️`range` **Bounded**:\n > _The total length of the `range` must be no larger than `isize::MAX`._\n\n \n‼️`range` **Dereferencable**:\n > _The entire memory range of this slice must be contained within a single allocated object! Slices can never span across multiple allocated objects._\n\n \n‼️`range` **Initialized**:\n > _The range must contain `N` consecutive properly initialized values of type `T`._\n\n \n‼️`range` **Layout**:\n > _The `start` pointer of the range must be properly aligned to the first element of a slice._\n\n > _The `end` pointer of the range must be to one past the last element._\n\n > _This function panics if `T` is a Zero-Sized Type (ZST)._\n\n \n‼️`retval` **Aliased**:\n > _The memory referenced by the returned slice must not be mutated for the duration of lifetime `'a`._\n\n > _The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse, it's suggested to tie the lifetime to whichever source lifetime is safe in the context._\n\n \n\n","num/struct.NonZeroI128.html#method.new_unchecked":"‼️`n` **Bounded**:\n > _The value must not be zero._\n\n \n\n","primitive.i32.html#method.forward_unchecked":"‼️`start` **Bounded**:\n > _`start` + `count` may overflow the range of values supported by `i32::MAX`._\n\n \n\n","primitive.i32.html#method.unchecked_mul":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self * rhs > i32::MAX` or `self * rhs < i32::MIN`._\n\n \n\n","ops/struct.RangeFrom.html#method.get_unchecked_mut-1":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","mem/fn.transmute.html":"‼️`retval` **Aliased**:\n > _It can turn a `*mut T` into an `&mut T`._\n\n > _It can extend a lifetime, or shorten an invariant lifetime._\n\n \n‼️`retval` **Initialized**:\n > _Both the argument and the result must be valid at their given type._\n\n \n‼️`retval` **Untyped**:\n > _It is therefore your responsibility to guarantee that every value passed to transmute is valid at both types `Src` and `Dst`. Failing to uphold this condition may lead to unexpected and unstable compilation results._\n\n \n‼️`src` **Initialized**:\n > _Both the argument and the result must be valid at their given type._\n\n > _To transmute the inner type of the contents of a container, you must make sure to not violate any of the container's invariants._\n\n \n‼️`src` **Layout**:\n > _Both types must have the same size._\n\n > _Note that source and destination are passed by-value, which means if `Src` or `Dst` contain padding, that padding is not guaranteed to be preserved by transmute._\n\n > _When transmuting values that point elsewhere (such as pointers, references, boxes…), the caller has to ensure proper alignment of the pointed-to values._\n\n \n\n","intrinsics/fn.copy.html":"‼️`dst` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`dst` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`dst` **DualOwned**:\n > _If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*dst` can violate memory safety. Note that assigning to `*dst` counts as a use because it will attempt to drop the value at `*dst`._\n\n \n‼️`dst` **Layout**:\n > _`dst` must be properly aligned._\n\n \n‼️`dst` **Leaked**:\n > __\n\n \n‼️`dst` **Untyped**:\n > _The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`._\n\n \n‼️`src` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`src` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`src` **Layout**:\n > _`src` must be properly aligned._\n\n \n\n","ops/struct.RangeInclusive.html#method.get_unchecked":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","intrinsics/fn.ctlz_nonzero.html":"‼️`x` **Bounded**:\n > _Like `ctlz`, but extra-unsafe as it returns `undef` when given an `x` with value `0`._\n\n \n\n","num/struct.NonZeroUsize.html#method.unchecked_add":"‼️`self` **Bounded**:\n > _The behaviour is undefined as soon as `self + rhs > usize::MAX`._\n\n \n\n","slice/fn.from_raw_parts_mut.html#":"‼️`data` **Allocated**:\n > _`data` must be non-null even for zero-length slices._\n\n \n‼️`data` **Dereferencable**:\n > _The entire memory range (`len * mem::size_of::<T>()` bytes) of this slice must be contained within a single allocated object! Slices can never span across multiple allocated objects._\n\n \n‼️`data` **Initialized**:\n > _`data` must point to `len` consecutive properly initialized values of type `T`._\n\n \n‼️`data` **Layout**:\n > _`data` must be aligned even for zero-length slices._\n\n \n‼️`len` **Bounded**:\n > _The total size `len * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`._\n\n \n‼️`retval` **Aliased**:\n > _The memory referenced by the returned slice must not be mutated for the duration of lifetime `'a`._\n\n > _The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse, it's suggested to tie the lifetime to whichever source lifetime is safe in the context._\n\n \n\n","primitive.isize.html#method.forward_unchecked":"‼️`start` **Bounded**:\n > _`start` + `count` may overflow the range of values supported by `isize::MAX`._\n\n \n\n","ptr/struct.NonNull.html#method.sub":"‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Bounded**:\n > _The computed offset cannot exceed `isize::MAX` bytes._\n\n \n‼️`self` **Dereferencable**:\n > _Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object._\n\n \n\n","primitive.u128.html#method.forward_unchecked":"‼️`start` **Bounded**:\n > _`start` + `count` may overflow the range of values supported by `u128::MAX`._\n\n \n\n","ptr/fn.write_bytes.html":"‼️`dst` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`dst` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`dst` **Layout**:\n > _`dst` must be properly aligned._\n\n \n‼️`dst` **Leaked**:\n > __\n\n \n‼️`dst` **Untyped**:\n > _Additionally, note that changing `dst` in this way can easily lead to undefined behavior (UB) later if the written bytes are not a valid representation of some `T`._\n\n \n\n","primitive.u32.html#method.unchecked_shr":"‼️`self` **Bounded**:\n > _This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`._\n\n \n\n","any/trait.Any.html#method.downcast_ref_unchecked":"‼️`self` **Initialized**:\n > _The contained value must be of type `T`._\n\n \n\n","intrinsics/fn.cttz_nonzero.html":"‼️`x` **Bounded**:\n > _Like `cttz`, but extra-unsafe as it returns `undef` when given an `x` with value `0`._\n\n \n\n","primitive.i16.html#method.unchecked_shl":"‼️`self` **Bounded**:\n > _This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`._\n\n \n\n","os/fd/trait.FromRawFd.html#tymethod.from_raw_fd":"‼️`fd` **SystemIO**:\n > _The `fd` passed in must be an owned file descriptor; in particular, it must be open._\n\n \n\n","os/windows/io/struct.HandleOrInvalid.html#method.from_raw_handle":"‼️`handle` **SystemIO**:\n > _The passed handle value must either satisfy the safety requirements of `FromRawHandle::from_raw_handle` (below), or be `INVALID_HANDLE_VALUE` (-1)._\n\n > _`handle` must be an owned handle; in particular, it must be open._\n\n > _`handle` must be a handle for a resource that may be freed via `CloseHandle`._\n\n \n\n","rc/struct.Rc.html#method.decrement_strong_count":"‼️`ptr` **Allocated**:\n > _`ptr` must point to a block of memory allocated by the global allocator._\n\n \n‼️`ptr` **Bounded**:\n > _The associated `Rc` instance must be valid (i.e. the strong count must be at least 1) when invoking this method._\n\n \n‼️`ptr` **Freed**:\n > _This method can be used to release the final `Rc` and backing storage, but should not be called after the final `Rc` has been released._\n\n \n‼️`ptr` **Initialized**:\n > _The pointer must have been obtained through `Rc::into_raw`._\n\n \n\n","primitive.u32.html#method.unchecked_shl":"‼️`self` **Bounded**:\n > _This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`._\n\n \n\n","primitive.tuple.html#method.get_unchecked":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","sync/atomic/struct.AtomicUsize.html#method.from_ptr":"‼️`ptr` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`ptr` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`ptr` **Layout**:\n > _`ptr` must be aligned to `align_of::<AtomicUsize>()`._\n\n \n‼️`ptr` **Thread**:\n > _You must adhere to the Memory model for atomic accesses. In particular, it is not allowed to mix atomic and non-atomic accesses, or atomic accesses of different sizes, without synchronization._\n\n \n‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n\n","ptr/fn.swap.html":"‼️`x` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`x` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`x` **Layout**:\n > _`x` must be properly aligned._\n\n \n‼️`x` **Untyped**:\n > _The operation is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`._\n\n \n‼️`y` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`y` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`y` **Layout**:\n > _`y` must be properly aligned._\n\n \n‼️`y` **Untyped**:\n > _The operation is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`._\n\n \n\n","primitive.pointer.html#method.byte_add-1":"‼️`self` **Allocated**:\n > __\n\n \n‼️`self` **Bounded**:\n > _The computed offset cannot exceed `isize::MAX` bytes._\n\n \n‼️`self` **Dereferencable**:\n > _Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object._\n\n \n\n","num/struct.NonZeroI16.html#method.new_unchecked":"‼️`n` **Bounded**:\n > _The value must not be zero._\n\n \n\n","primitive.u64.html#method.unchecked_shl":"‼️`self` **Bounded**:\n > _This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`._\n\n \n\n","sync/struct.Arc.html#method.increment_strong_count":"‼️`ptr` **Allocated**:\n > _`ptr` must point to a block of memory allocated by the global allocator._\n\n \n‼️`ptr` **Bounded**:\n > _The associated `Arc` instance must be valid (i.e. the strong count must be at least 1) for the duration of this method._\n\n \n‼️`ptr` **Initialized**:\n > _The pointer must have been obtained through `Arc::into_raw`._\n\n \n\n","ops/struct.RangeFull.html#method.get_unchecked":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","mem/union.MaybeUninit.html#method.slice_assume_init_ref":"‼️`slice` **Initialized**:\n > _It is up to the caller to guarantee that the `MaybeUninit<T>` elements really are in an initialized state._\n\n \n\n","os/windows/io/struct.BorrowedSocket.html#method.borrow_raw":"‼️`socket` **Bounded**:\n > _The resource pointed to by raw must not have the value `INVALID_SOCKET`._\n\n \n‼️`socket` **SystemIO**:\n > _The resource pointed to by `raw` must remain open for the duration of the returned `BorrowedSocket`._\n\n \n\n","ffi/struct.CString.html#method.from_vec_unchecked":"‼️`v` **Initialized**:\n > _This method is equivalent to `CString::new` except that no runtime assertion is made that `v` contains no 0 bytes, and it requires an actual byte vector, not anything that can be converted to one with `Into`._\n\n \n\n","primitive.pointer.html#method.as_mut":"‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get accessed (read or written) through any other pointer._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n‼️`self` **Allocated**:\n > _Either the pointer is null or all of the following is true._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Initialized**:\n > _The pointer must point to an initialized instance of `T`._\n\n \n‼️`self` **Layout**:\n > _The pointer must be properly aligned._\n\n \n\n","primitive.str.html#method.get_unchecked":"‼️`i` **Bounded**:\n > _The starting index must not exceed the ending index._\n\n > _Indexes must be within bounds of the original slice._\n\n \n‼️`i` **Initialized**:\n > _Indexes must lie on UTF-8 sequence boundaries._\n\n \n\n","rc/struct.Rc.html#method.assume_init":"‼️`self` **Initialized**:\n > _It is up to the caller to guarantee that the inner value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior._\n\n \n\n","mem/struct.ManuallyDrop.html#method.drop":"‼️`slot` **Freed**:\n > _This function runs the destructor of the contained value. The zombie value should not be exposed to safe code after been dropped, and this function should not be called more than once._\n\n \n\n","intrinsics/fn.vtable_size.html":"‼️`ptr` **EST**:\n > _`ptr` must point to a vtable._\n\n \n\n","ffi/struct.CStr.html#method.from_bytes_with_nul_unchecked":"‼️`bytes` **Initialized**:\n > _The provided slice must be nul-terminated and not contain any interior nul bytes._\n\n \n\n","primitive.pointer.html#method.read_unaligned-1":"‼️`retval` **DualOwned**:\n > _If `T` is not `Copy`, using both the returned value and the value at `self` can violate memory safety. Note that assigning to `self` counts as a use because it will attempt to drop the value at `self`._\n\n \n‼️`self` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Initialized**:\n > _`self` must point to a properly initialized value of type `T`._\n\n \n\n","primitive.isize.html#method.unchecked_mul":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self * rhs > isize::MAX` or `self * rhs < isize::MIN`._\n\n \n\n","ptr/struct.NonNull.html#method.drop_in_place":"‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Freed**:\n > _Executes the destructor (if any) of the pointed-to value._\n\n \n‼️`self` **Initialized**:\n > _The value `self` points to must be valid for dropping, which may mean it must uphold additional invariants. These invariants depend on the type of the value being dropped._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned, even if `T` has size 0._\n\n > _Unaligned values cannot be dropped in place, they must be copied to an aligned location first using `ptr::read_unaligned`._\n\n \n\n","primitive.u32.html#method.unchecked_mul":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self * rhs > u32::MAX` or `self * rhs < u32::MIN`._\n\n \n\n","primitive.pointer.html#method.replace":"‼️`self` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Initialized**:\n > _`self` must point to a properly initialized value of type `T`._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned._\n\n \n‼️`src` **Leaked**:\n > _Neither value is dropped._\n\n \n\n","pin/struct.Pin.html#method.map_unchecked":"‼️`retval` **Pinned**:\n > _The data you return will not move so long as the argument value does not move (for example, because it is one of the fields of that value), and also that you do not move out of the argument you receive to the interior function._\n\n \n\n","boxed/struct.Box.html#method.downcast_unchecked":"‼️`self` **Initialized**:\n > _The contained value must be of type `T`._\n\n \n\n","mem/union.MaybeUninit.html#method.assume_init_ref":"‼️`self` **Initialized**:\n > _It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized state._\n\n \n\n","primitive.i32.html#method.backward_unchecked":"‼️`start` **Bounded**:\n > _`start` - `count` may overflow the range of values supported by `i32::MIN`._\n\n \n\n","sync/atomic/struct.AtomicBool.html#method.from_ptr":"‼️`ptr` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`ptr` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`ptr` **Layout**:\n > _`ptr` must be aligned to `align_of::<AtomicBool>()`._\n\n \n‼️`ptr` **Thread**:\n > _You must adhere to the Memory model for atomic accesses. In particular, it is not allowed to mix atomic and non-atomic accesses, or atomic accesses of different sizes, without synchronization._\n\n \n‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n\n","num/struct.NonZeroI128.html#method.unchecked_mul":"‼️`self` **Bounded**:\n > _The behaviour is undefined as soon as `self * rhs > i128::MAX`, or `self * rhs < i128::MIN`._\n\n \n\n","primitive.usize.html#method.unchecked_sub":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self - rhs > usize::MAX` or `self - rhs < usize::MIN`._\n\n \n\n","alloc/struct.Layout.html#method.for_value_raw":"‼️`t` **Bounded**:\n > _If the unsized tail of `T` is a slice, then the length of the slice tail must be an initialized integer, and the size of the entire value (dynamic tail length + statically sized prefix) must fit in `isize`._\n\n > _If the unsized tail of `T` is a trait object, then the vtable part of the pointer must point to a valid vtable for the type `T` acquired by an unsizing coercion, and the size of the entire value (dynamic tail length + statically sized prefix) must fit in `isize`._\n\n \n‼️`t` **Layout**:\n > _If the unsized tail of `T` is a slice, then the length of the slice tail must be an initialized integer, and the size of the entire value (dynamic tail length + statically sized prefix) must fit in `isize`._\n\n > _If the unsized tail of `T` is a trait object, then the vtable part of the pointer must point to a valid vtable for the type `T` acquired by an unsizing coercion, and the size of the entire value (dynamic tail length + statically sized prefix) must fit in `isize`._\n\n \n\n","primitive.i8.html#method.unchecked_shl":"‼️`self` **Bounded**:\n > _This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`._\n\n \n\n","primitive.isize.html#method.unchecked_add":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self + rhs > isize::MAX` or `self + rhs < isize::MIN`._\n\n \n\n","primitive.i32.html#method.unchecked_shr":"‼️`self` **Bounded**:\n > _This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`._\n\n \n\n","num/struct.NonZeroU128.html#method.unchecked_add":"‼️`self` **Bounded**:\n > _The behaviour is undefined as soon as `self + rhs > u128::MAX`._\n\n \n\n","alloc/trait.Allocator.html#tymethod.deallocate":"‼️`layout` **Layout**:\n > _`layout` must fit that block of memory._\n\n \n‼️`ptr` **Allocated**:\n > _`ptr` must denote a block of memory currently allocated via this allocator._\n\n \n\n","array/struct.IntoIter.html#method.new_unchecked":"‼️`buffer` **Initialized**:\n > _The `buffer[initialized]` elements must all be initialized._\n\n \n‼️`initialized` **Bounded**:\n > _The range must be in-bounds for the buffer, with `initialized.end <= N`._\n\n > _The range must be canonical, with `initialized.start` <= `initialized.end`._\n\n \n\n","ptr/struct.NonNull.html#method.read_unaligned":"‼️`retval` **DualOwned**:\n > _If `T` is not `Copy`, using both the returned value and the value at `self` can violate memory safety. Note that assigning to `self` counts as a use because it will attempt to drop the value at `self`._\n\n \n‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Initialized**:\n > _`self` must point to a properly initialized value of type `T`._\n\n \n\n","sync/atomic/struct.AtomicI64.html#method.from_ptr":"‼️`ptr` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`ptr` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`ptr` **Layout**:\n > _`ptr` must be aligned to `align_of::<AtomicI64>()`._\n\n \n‼️`ptr` **Thread**:\n > _You must adhere to the Memory model for atomic accesses. In particular, it is not allowed to mix atomic and non-atomic accesses, or atomic accesses of different sizes, without synchronization._\n\n \n‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n\n","num/struct.NonZeroI8.html#method.unchecked_mul":"‼️`self` **Bounded**:\n > _The behaviour is undefined as soon as `self * rhs > i8::MAX`, or `self * rhs < i8::MIN`._\n\n \n\n","sync/struct.Weak.html#method.from_raw":"‼️`ptr` **Allocated**:\n > _`ptr` must point to a block of memory allocated by the global allocator._\n\n \n‼️`ptr` **Initialized**:\n > _The pointer must have originated from the `Weak::into_raw` and must still own its potential weak reference._\n\n \n‼️`retval` **DualOwned**:\n > _It takes ownership of one weak reference. This can be used to deallocate the weak count by dropping the `Weak<T>`._\n\n \n\n","rc/struct.Rc.html#method.from_raw_in":"‼️`ptr` **Allocated**:\n > _The raw pointer must point to a block of memory allocated by `alloc` in the provided allocator._\n\n \n‼️`ptr` **Initialized**:\n > _The raw pointer must have been previously returned by a call to `Rc<U>::into_raw`._\n\n > _Note that if `U` is not `T` but has the same size and alignment, this is basically like transmuting references of different types._\n\n \n‼️`ptr` **Layout**:\n > _`Rc<U>::into_raw` where `U` must have the same size and alignment as `T`._\n\n \n‼️`retval` **DualOwned**:\n > _The user of `from_raw` has to make sure a specific value of `T` is only dropped once._\n\n \n\n","os/windows/io/trait.FromRawHandle.html#tymethod.from_raw_handle":"‼️`handle` **SystemIO**:\n > _`handle` must be an owned handle; in particular, it must be open._\n\n > _`handle` must be a handle for a resource that may be freed via `CloseHandle`._\n\n \n\n","ptr/struct.NonNull.html#method.as_uninit_slice_mut":"‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get accessed (read or written) through any other pointer._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Bounded**:\n > _The total size `ptr.len() * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`._\n\n \n‼️`self` **Dereferencable**:\n > _The entire memory range of this slice (`ptr.len() * mem::size_of::<T>()` bytes) must be contained within a single allocated object! Slices can never span across multiple allocated objects._\n\n \n‼️`self` **Layout**:\n > _The pointer must be aligned even for zero-length slices._\n\n \n\n","thread/struct.Builder.html#method.spawn_unchecked":"‼️`retval` **Aliased**:\n > _The spawned thread may outlive the caller. The caller has to ensure that the spawned thread does not outlive any references in the supplied thread closure and its return type._\n\n \n‼️`self` **Initialized**:\n > _Panics if a thread name was set and it contained null bytes._\n\n \n\n","mem/union.MaybeUninit.html#method.assume_init_mut":"‼️`self` **Initialized**:\n > _It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized state._\n\n \n\n","primitive.pointer.html#method.sub_ptr":"‼️`origin` **Allocated**:\n > __\n\n \n‼️`origin` **Dereferencable**:\n > _`origin` must be either in bounds or one byte past the end of the same allocated object._\n\n \n‼️`self` **Allocated**:\n > __\n\n \n‼️`self` **Bounded**:\n > _The distance between the pointers, in bytes, cannot overflow an `isize`._\n\n > _The distance between the pointers, in bytes, must be an exact multiple of the size of `T`._\n\n > _The distance between the pointers must be non-negative (`self` >= `origin`)._\n\n \n‼️`self` **Dereferencable**:\n > _`self` must be either in bounds or one byte past the end of the same allocated object._\n\n > _Both pointers must be derived from a pointer to the same object._\n\n \n‼️`self` **Layout**:\n > _This function panics if `T` is a Zero-Sized Type (ZST)._\n\n \n\n","process/struct.Stdio.html#method.from_raw_handle":"‼️`handle` **SystemIO**:\n > _`handle` must be an owned handle; in particular, it must be open._\n\n > _`handle` must be a handle for a resource that may be freed via `CloseHandle`._\n\n \n\n","mem/union.MaybeUninit.html#method.assume_init_read":"‼️`retval` **DualOwned**:\n > _This function creates a bitwise copy of the contents, regardless whether the contained type implements the `Copy` trait or not. When using multiple copies of the data (by calling `assume_init_read` multiple times, or first calling `assume_init_read` and then `assume_init`), it is your responsibility to ensure that data may indeed be duplicated._\n\n \n‼️`self` **Initialized**:\n > _It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized state._\n\n \n\n","ptr/fn.replace.html":"‼️`dst` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`dst` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`dst` **Initialized**:\n > _`dst` must point to a properly initialized value of type `T`._\n\n \n‼️`dst` **Layout**:\n > _`dst` must be properly aligned._\n\n \n‼️`src` **Leaked**:\n > _Neither value is dropped._\n\n \n\n","primitive.pointer.html#method.as_uninit_slice":"‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n‼️`self` **Allocated**:\n > _Either the pointer is null or all of the following is true._\n\n \n‼️`self` **Bounded**:\n > _The total size `ptr.len() * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`._\n\n \n‼️`self` **Dereferencable**:\n > _The entire memory range of this slice (`ptr.len() * mem::size_of::<T>()` bytes) must be contained within a single allocated object! Slices can never span across multiple allocated objects._\n\n \n‼️`self` **Layout**:\n > _The pointer must be aligned even for zero-length slices._\n\n \n\n","primitive.u32.html#method.unchecked_add":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self + rhs > u32::MAX` or `self + rhs < u32::MIN`._\n\n \n\n","primitive.pointer.html#method.as_ref":"‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n‼️`self` **Allocated**:\n > _Either the pointer is null or all of the following is true._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Initialized**:\n > _The pointer must point to an initialized instance of `T`._\n\n \n‼️`self` **Layout**:\n > _The pointer must be properly aligned._\n\n \n\n","str/fn.from_boxed_utf8_unchecked.html":"‼️`v` **Initialized**:\n > _Converts a boxed slice of bytes to a boxed string slice without checking that the string contains valid UTF-8._\n\n \n\n","primitive.u16.html#method.forward_unchecked":"‼️`start` **Bounded**:\n > _`start` + `count` may overflow the range of values supported by `u16::MAX`._\n\n \n\n","os/windows/io/struct.OwnedSocket.html#method.from_raw_socket":"‼️`socket` **SystemIO**:\n > _`socket` must be an owned socket; in particular, it must be open._\n\n > _`socket` must be a socket that may be freed via `closesocket`._\n\n \n\n","process/struct.Stdio.html#method.from_raw_fd":"‼️`fd` **SystemIO**:\n > _The `fd` passed in must be an owned file descriptor; in particular, it must be open._\n\n \n\n","rc/struct.Rc.html#method.increment_strong_count_in":"‼️`ptr` **Allocated**:\n > _`ptr` must point to a block of memory allocated by allocated by `alloc` in the provided allocator._\n\n \n‼️`ptr` **Bounded**:\n > _The associated `Rc` instance must be valid (i.e. the strong count must be at least 1) for the duration of this method._\n\n \n‼️`ptr` **Initialized**:\n > _The pointer must have been obtained through `Rc::into_raw`._\n\n \n\n","primitive.pointer.html#method.byte_offset":"‼️`self` **Allocated**:\n > __\n\n \n‼️`self` **Bounded**:\n > _The computed offset, in bytes, cannot overflow an `isize`._\n\n \n‼️`self` **Dereferencable**:\n > _Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object._\n\n \n\n","ops/struct.RangeInclusive.html#method.get_unchecked_mut-1":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","intrinsics/fn.fadd_fast.html":"‼️`x` **Bounded**:\n > _Float addition that allows optimizations based on algebraic rules. The calculated result cannot overflow `T::MAX` or `T::MIN`._\n\n \n\n","boxed/struct.Box.html#method.downcast_unchecked-1":"‼️`self` **Initialized**:\n > _The contained value must be of type `T`._\n\n \n\n","num/struct.NonZeroIsize.html#method.unchecked_mul":"‼️`self` **Bounded**:\n > _The behaviour is undefined as soon as `self * rhs > isize::MAX`, or `self * rhs < isize::MIN`._\n\n \n\n","primitive.str.html#method.slice_mut_unchecked":"‼️`begin` **Bounded**:\n > _`begin` must not exceed `end`._\n\n > _`begin` must be byte positions within the string slice._\n\n \n‼️`begin` **Initialized**:\n > _`begin` must lie on UTF-8 sequence boundaries._\n\n \n‼️`end` **Bounded**:\n > _`end` must be byte positions within the string slice._\n\n \n‼️`end` **Initialized**:\n > _`end` must lie on UTF-8 sequence boundaries._\n\n \n\n","primitive.u128.html#method.unchecked_add":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self + rhs > u128::MAX` or `self + rhs < u128::MIN`._\n\n \n\n","ops/struct.RangeFull.html#method.get_unchecked_mut-1":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","collections/hash_map/struct.HashMap.html#method.get_many_unchecked_mut":"‼️`retval` **Aliased**:\n > _Calling this method with overlapping keys is undefined behavior even if the resulting references are not used._\n\n \n\n","primitive.i64.html#method.unchecked_mul":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self * rhs > i64::MAX` or `self * rhs < i64::MIN`._\n\n \n\n","sync/struct.Arc.html#method.assume_init":"‼️`self` **Initialized**:\n > _It is up to the caller to guarantee that the inner value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior._\n\n \n\n","primitive.pointer.html#method.copy_to_nonoverlapping-1":"‼️`dest` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`dest` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n > _The region of memory beginning at `self` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `dest` with the same size._\n\n \n‼️`dest` **DualOwned**:\n > _If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*dest` can violate memory safety. Note that assigning to `*dest` counts as a use because it will attempt to drop the value at `*dest`._\n\n \n‼️`dest` **Layout**:\n > _`dest` must be properly aligned._\n\n \n‼️`dest` **Leaked**:\n > __\n\n \n‼️`dest` **Untyped**:\n > _The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`._\n\n \n‼️`self` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n > _The region of memory beginning at `self` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `dest` with the same size._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned._\n\n \n\n","ops/struct.RangeToInclusive.html#method.get_unchecked":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","rc/struct.Rc.html#method.from_raw":"‼️`ptr` **Allocated**:\n > _The raw pointer must point to a block of memory allocated by the global allocator._\n\n \n‼️`ptr` **Initialized**:\n > _The raw pointer must have been previously returned by a call to `Rc<U>::into_raw`._\n\n > _Note that if `U` is not `T` but has the same size and alignment, this is basically like transmuting references of different types._\n\n \n‼️`ptr` **Layout**:\n > _`Rc<U>::into_raw` where `U` must have the same size and alignment as `T`._\n\n \n‼️`retval` **DualOwned**:\n > _The user of `from_raw` has to make sure a specific value of `T` is only dropped once._\n\n \n\n","intrinsics/fn.unaligned_volatile_store.html":"‼️`dst` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`dst` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`dst` **Leaked**:\n > _This is safe, but it could leak allocations or resources, so care should be taken not to overwrite an object that should be dropped._\n\n \n\n","os/windows/io/struct.HandleOrNull.html#method.from_raw_handle":"‼️`handle` **SystemIO**:\n > _The passed handle value must either satisfy the safety requirements of `FromRawHandle::from_raw_handle` (below), or be null._\n\n > _`handle` must be an owned handle; in particular, it must be open._\n\n > _`handle` must be a handle for a resource that may be freed via `CloseHandle`._\n\n \n\n","alloc/trait.Allocator.html#method.grow_zeroed":"‼️`new_layout` **Bounded**:\n > _`new_layout.size()` must be greater than or equal to `old_layout.size()`._\n\n \n‼️`old_layout` **Layout**:\n > _`old_layout` must fit that block of memory._\n\n \n‼️`ptr` **Allocated**:\n > _`ptr` must denote a block of memory currently allocated via this allocator._\n\n \n‼️`ptr` **Freed**:\n > _If this returns `Ok`, then ownership of the memory block referenced by `ptr` has been transferred to this allocator. _\n\n \n‼️`retval` **Untyped**:\n > _The allocated block of memory is guaranteed to be initialized but may be untyped._\n\n \n\n","convert/trait.FloatToInt.html":"‼️`self` **Bounded**:\n > _The value must not be `NaN`._\n\n > _The value must not be infinite._\n\n > _The value must be representable in the return type `Int`, after truncating off its fractional part._\n\n \n\n","ptr/struct.NonNull.html#method.get_unchecked_mut":"‼️`index` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting pointer is not used._\n\n \n‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _When `self` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","os/windows/io/struct.OwnedHandle.html#method.from_raw_handle":"‼️`handle` **SystemIO**:\n > _`handle` must be an owned handle; in particular, it must be open._\n\n > _`handle` must be a handle for a resource that may be freed via `CloseHandle`._\n\n \n\n","primitive.pointer.html#method.copy_from_nonoverlapping":"‼️`self` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n > _The region of memory beginning at `self` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `src` with the same size._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned._\n\n \n‼️`self` **Leaked**:\n > __\n\n \n‼️`src` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`src` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n > _The region of memory beginning at `self` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `src` with the same size._\n\n \n‼️`src` **DualOwned**:\n > _If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*src` can violate memory safety. Note that assigning to `*src` counts as a use because it will attempt to drop the value at `*src`._\n\n \n‼️`src` **Layout**:\n > _`src` must be properly aligned._\n\n \n‼️`src` **Untyped**:\n > _The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`._\n\n \n\n","primitive.char.html#method.forward_unchecked":"‼️`start` **Bounded**:\n > _`start` + `count` may overflow the range of values supported by `char::MAX`._\n\n \n\n","primitive.slice.html#method.get_unchecked":"‼️`index` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n\n","ptr/fn.copy.html":"‼️`dst` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`dst` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`dst` **DualOwned**:\n > _If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*dst` can violate memory safety. Note that assigning to `*dst` counts as a use because it will attempt to drop the value at `*dst`._\n\n \n‼️`dst` **Layout**:\n > _`dst` must be properly aligned._\n\n \n‼️`dst` **Leaked**:\n > __\n\n \n‼️`dst` **Untyped**:\n > _The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`._\n\n \n‼️`src` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`src` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`src` **Layout**:\n > _`src` must be properly aligned._\n\n \n\n","ops/struct.RangeToInclusive.html#method.get_unchecked-1":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","ptr/struct.NonNull.html#method.as_uninit_mut":"‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get accessed (read or written) through any other pointer._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Layout**:\n > _The pointer must be properly aligned._\n\n \n\n","primitive.pointer.html#method.split_at_mut_unchecked":"‼️`mid` **Bounded**:\n > _Panics if `mid` > `len`._\n\n > _`mid` must be in-bounds of the underlying allocated object._\n\n \n‼️`self` **Allocated**:\n > __\n\n \n‼️`self` **Dereferencable**:\n > _`self` must be dereferenceable and span a single allocation that is at least `mid * size_of::<T>()` bytes long._\n\n \n\n","primitive.usize.html#method.get_unchecked_mut":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","primitive.char.html#method.from_u32_unchecked":"‼️`i` **Initialized**:\n > _Not all valid `u32`s are valid `char`s, it may construct invalid `char` values._\n\n \n\n","num/struct.NonZeroU8.html#method.unchecked_mul":"‼️`self` **Bounded**:\n > _The behaviour is undefined as soon as `self * rhs > u8::MAX`._\n\n \n\n","primitive.pointer.html#method.copy_from":"‼️`self` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned._\n\n \n‼️`self` **Leaked**:\n > __\n\n \n‼️`src` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`src` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`src` **DualOwned**:\n > _If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*src` can violate memory safety. Note that assigning to `*src` counts as a use because it will attempt to drop the value at `*src`._\n\n \n‼️`src` **Layout**:\n > _`src` must be properly aligned._\n\n \n‼️`src` **Untyped**:\n > _The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`._\n\n \n\n","ops/struct.RangeInclusive.html#method.get_unchecked_mut":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","alloc/struct.Layout.html#method.from_size_align_unchecked":"‼️`align` **Bounded**:\n > _`align` must not be zero._\n\n > _`align` must be a power of two._\n\n \n‼️`size` **Bounded**:\n > _`size`, when rounded up to the nearest multiple of `align`, must not overflow `isize::MAX`._\n\n \n\n","ops/struct.Range.html#method.get_unchecked":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","primitive.pointer.html#method.drop_in_place":"‼️`self` **Allocated**:\n > _`self` must be nonnull, even if T has size 0._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Freed**:\n > _Executes the destructor (if any) of the pointed-to value._\n\n \n‼️`self` **Initialized**:\n > _The value `self` points to must be valid for dropping, which may mean it must uphold additional invariants. These invariants depend on the type of the value being dropped._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned, even if `T` has size 0._\n\n > _Unaligned values cannot be dropped in place, they must be copied to an aligned location first using `ptr::read_unaligned`._\n\n \n\n","intrinsics/fn.vtable_align.html":"‼️`ptr` **EST**:\n > _`ptr` must point to a vtable._\n\n \n\n","primitive.u8.html#method.unchecked_shr":"‼️`self` **Bounded**:\n > _This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`._\n\n \n\n","intrinsics/fn.unchecked_sub.html":"‼️`x` **Bounded**:\n > _Returns the result of an unchecked subtraction, resulting in undefined behavior when `x - y > T::MAX` or `x - y < T::MIN`._\n\n \n\n","primitive.pointer.html#method.write_unaligned":"‼️`self` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Leaked**:\n > _This is safe, but it could leak allocations or resources, so care should be taken not to overwrite an object that should be dropped._\n\n \n\n","primitive.pointer.html#method.write_volatile":"‼️`self` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned._\n\n \n‼️`self` **Leaked**:\n > _This is safe, but it could leak allocations or resources, so care should be taken not to overwrite an object that should be dropped._\n\n \n\n","num/struct.NonZeroU16.html#method.unchecked_mul":"‼️`self` **Bounded**:\n > _The behaviour is undefined as soon as `self * rhs > u16::MAX`._\n\n \n\n","primitive.pointer.html#method.read_unaligned":"‼️`retval` **DualOwned**:\n > _If `T` is not `Copy`, using both the returned value and the value at `self` can violate memory safety. Note that assigning to `self` counts as a use because it will attempt to drop the value at `self`._\n\n \n‼️`self` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Initialized**:\n > _`self` must point to a properly initialized value of type `T`._\n\n \n\n","ptr/struct.NonNull.html#method.byte_offset":"‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Bounded**:\n > _The computed offset, in bytes, cannot overflow an `isize`._\n\n \n‼️`self` **Dereferencable**:\n > _Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object._\n\n \n\n","os/fd/type.RawFd.html#method.from_raw_fd":"‼️`fd` **SystemIO**:\n > _The `fd` passed in must be an owned file descriptor; in particular, it must be open._\n\n \n\n","hint/fn.unreachable_unchecked.html":"‼️`NULL` **Unreachable**:\n > _Reaching this function is Undefined Behavior._\n\n > _It will safely panic in case it is actually reached at runtime._\n\n \n\n","sync/atomic/struct.AtomicU8.html#method.from_ptr":"‼️`ptr` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`ptr` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`ptr` **Layout**:\n > _`ptr` must be aligned to `align_of::<AtomicU8>()`._\n\n \n‼️`ptr` **Thread**:\n > _You must adhere to the Memory model for atomic accesses. In particular, it is not allowed to mix atomic and non-atomic accesses, or atomic accesses of different sizes, without synchronization._\n\n \n‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n\n","primitive.usize.html#method.backward_unchecked":"‼️`start` **Bounded**:\n > _`start` - `count` may overflow the range of values supported by `usize::MIN`._\n\n \n\n","primitive.usize.html#method.unchecked_shr":"‼️`self` **Bounded**:\n > _This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`._\n\n \n\n","intrinsics/fn.drop_in_place.html":"‼️`to_drop` **Allocated**:\n > _`to_drop` must be nonnull, even if T has size 0._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`to_drop` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`to_drop` **Freed**:\n > _Executes the destructor (if any) of the pointed-to value._\n\n \n‼️`to_drop` **Initialized**:\n > _The value `to_drop` points to must be valid for dropping, which may mean it must uphold additional invariants. These invariants depend on the type of the value being dropped._\n\n \n‼️`to_drop` **Layout**:\n > _`to_drop` must be properly aligned, even if `T` has size 0._\n\n > _Unaligned values cannot be dropped in place, they must be copied to an aligned location first using `ptr::read_unaligned`._\n\n \n\n","primitive.i64.html#method.unchecked_sub":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self - rhs > i64::MAX` or `self - rhs < i64::MIN`._\n\n \n\n","num/struct.NonZeroUsize.html#method.unchecked_mul":"‼️`self` **Bounded**:\n > _The behaviour is undefined as soon as `self * rhs > usize::MAX`._\n\n \n\n","primitive.i32.html#method.unchecked_sub":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self - rhs > i32::MAX` or `self - rhs < i32::MIN`._\n\n \n\n","sync/struct.Arc.html#method.decrement_strong_count":"‼️`ptr` **Allocated**:\n > _`ptr` must point to a block of memory allocated by the global allocator._\n\n \n‼️`ptr` **Bounded**:\n > _The associated `Arc` instance must be valid (i.e. the strong count must be at least 1) when invoking this method._\n\n \n‼️`ptr` **Freed**:\n > _This method can be used to release the final `Arc` and backing storage, but should not be called after the final `Arc` has been released._\n\n \n‼️`ptr` **Initialized**:\n > _The pointer must have been obtained through `Arc::into_raw`._\n\n \n\n","intrinsics/fn.fsub_fast.html":"‼️`x` **Bounded**:\n > _Float subtraction that allows optimizations based on algebraic rules. The calculated result cannot overflow `T::MAX` or `T::MIN`._\n\n \n\n","primitive.isize.html#method.unchecked_shl":"‼️`self` **Bounded**:\n > _This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`._\n\n \n\n","intrinsics/fn.transmute.html":"‼️`retval` **Aliased**:\n > _It can turn a `*mut T` into an `&mut T`._\n\n > _It can extend a lifetime, or shorten an invariant lifetime._\n\n \n‼️`retval` **Initialized**:\n > _Both the argument and the result must be valid at their given type._\n\n \n‼️`retval` **Untyped**:\n > _It is therefore your responsibility to guarantee that every value passed to transmute is valid at both types `Src` and `Dst`. Failing to uphold this condition may lead to unexpected and unstable compilation results._\n\n \n‼️`src` **Initialized**:\n > _Both the argument and the result must be valid at their given type._\n\n > _To transmute the inner type of the contents of a container, you must make sure to not violate any of the container's invariants._\n\n \n‼️`src` **Layout**:\n > _Both types must have the same size._\n\n > _Note that source and destination are passed by-value, which means if `Src` or `Dst` contain padding, that padding is not guaranteed to be preserved by transmute._\n\n > _When transmuting values that point elsewhere (such as pointers, references, boxes…), the caller has to ensure proper alignment of the pointed-to values._\n\n \n\n","net/struct.TcpListener.html#method.from_raw_fd":"‼️`fd` **SystemIO**:\n > _The `fd` passed in must be an owned file descriptor; in particular, it must be open._\n\n \n\n","primitive.pointer.html#method.sub":"‼️`self` **Allocated**:\n > __\n\n \n‼️`self` **Bounded**:\n > _The computed offset cannot exceed `isize::MAX` bytes._\n\n \n‼️`self` **Dereferencable**:\n > _Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object._\n\n \n\n","fs/struct.File.html#method.from_raw_fd":"‼️`fd` **SystemIO**:\n > _The `fd` passed in must be an owned file descriptor; in particular, it must be open._\n\n \n\n","ffi/struct.CStr.html#method.from_ptr":"‼️`ptr` **Allocated**:\n > _`ptr` must be non-null even for a zero-length cstr._\n\n \n‼️`ptr` **Bounded**:\n > _The nul terminator must be within `isize::MAX` from `ptr`._\n\n \n‼️`ptr` **Dereferencable**:\n > _The entire memory range of this `CStr` must be contained within a single allocated object!_\n\n \n‼️`ptr` **Initialized**:\n > _The memory pointed to by `ptr` must contain a valid nul terminator at the end of the string._\n\n \n‼️`retval` **Aliased**:\n > _The memory referenced by the returned `CStr` must not be mutated for the duration of lifetime `'a`._\n\n > _The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse, it's suggested to tie the lifetime to whichever source lifetime is safe in the context._\n\n \n\n","primitive.u64.html#method.unchecked_sub":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self - rhs > u64::MAX` or `self - rhs < u64::MIN`._\n\n \n\n","os/linux/process/struct.PidFd.html#method.from_raw_fd":"‼️`fd` **SystemIO**:\n > _The `fd` passed in must be an owned file descriptor; in particular, it must be open._\n\n \n\n","num/struct.NonZeroI32.html#method.unchecked_mul":"‼️`self` **Bounded**:\n > _The behaviour is undefined as soon as `self * rhs > i32::MAX`, or `self * rhs < i32::MIN`._\n\n \n\n","primitive.u16.html#method.unchecked_shl":"‼️`self` **Bounded**:\n > _This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`._\n\n \n\n","primitive.pointer.html#method.read_volatile":"‼️`retval` **DualOwned**:\n > _If `T` is not `Copy`, using both the returned value and the value at `self` can violate memory safety. Note that assigning to `self` counts as a use because it will attempt to drop the value at `self`._\n\n > _However, storing non-`Copy` types in volatile memory is almost certainly incorrect._\n\n \n‼️`self` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Initialized**:\n > _`self` must point to a properly initialized value of type `T`._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned._\n\n \n\n","primitive.pointer.html#method.as_uninit_slice_mut":"‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get accessed (read or written) through any other pointer._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n‼️`self` **Allocated**:\n > _Either the pointer is null or all of the following is true._\n\n \n‼️`self` **Bounded**:\n > _The total size `ptr.len() * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`._\n\n \n‼️`self` **Dereferencable**:\n > _The entire memory range of this slice (`ptr.len() * mem::size_of::<T>()` bytes) must be contained within a single allocated object! Slices can never span across multiple allocated objects._\n\n \n‼️`self` **Layout**:\n > _The pointer must be aligned even for zero-length slices._\n\n \n\n","slice/fn.from_raw_parts.html#":"‼️`data` **Allocated**:\n > _`data` must be non-null even for zero-length slices._\n\n \n‼️`data` **Dereferencable**:\n > _The entire memory range (`len * mem::size_of::<T>()` bytes) of this slice must be contained within a single allocated object! Slices can never span across multiple allocated objects._\n\n \n‼️`data` **Initialized**:\n > _`data` must point to `len` consecutive properly initialized values of type `T`._\n\n \n‼️`data` **Layout**:\n > _`data` must be aligned even for zero-length slices._\n\n \n‼️`len` **Bounded**:\n > _The total size `len * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`._\n\n \n‼️`retval` **Aliased**:\n > _The memory referenced by the returned slice must not be mutated for the duration of lifetime `'a`._\n\n > _The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse, it's suggested to tie the lifetime to whichever source lifetime is safe in the context._\n\n \n\n","intrinsics/fn.unaligned_volatile_load.html":"‼️`retval` **DualOwned**:\n > _If `T` is not `Copy`, using both the returned value and the value at `src` can violate memory safety. Note that assigning to `src` counts as a use because it will attempt to drop the value at `src`._\n\n > _However, storing non-`Copy` types in volatile memory is almost certainly incorrect._\n\n \n‼️`src` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`src` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`src` **Initialized**:\n > _`src` must point to a properly initialized value of type `T`._\n\n \n\n","mem/union.MaybeUninit.html#method.slice_assume_init_mut":"‼️`slice` **Initialized**:\n > _It is up to the caller to guarantee that the `MaybeUninit<T>` elements really are in an initialized state._\n\n \n\n","any/trait.Any.html#method.downcast_ref_unchecked-2":"‼️`self` **Initialized**:\n > _The contained value must be of type `T`._\n\n \n\n","primitive.i64.html#method.forward_unchecked":"‼️`start` **Bounded**:\n > _`start` + `count` may overflow the range of values supported by `i64::MAX`._\n\n \n\n","primitive.pointer.html#method.offset-1":"‼️`self` **Allocated**:\n > __\n\n \n‼️`self` **Bounded**:\n > _The computed offset, in bytes, cannot overflow an `isize`._\n\n \n‼️`self` **Dereferencable**:\n > _Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object._\n\n \n\n","primitive.u8.html#method.backward_unchecked":"‼️`start` **Bounded**:\n > _`start` - `count` may overflow the range of values supported by `u8::MIN`._\n\n \n\n","primitive.u8.html#method.unchecked_sub":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self - rhs > u8::MAX` or `self - rhs < u8::MIN`._\n\n \n\n","sync/atomic/struct.AtomicPtr.html#method.from_ptr":"‼️`ptr` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`ptr` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`ptr` **Layout**:\n > _`ptr` must be aligned to `align_of::<AtomicPtr<T>>()`._\n\n \n‼️`ptr` **Thread**:\n > _You must adhere to the Memory model for atomic accesses. In particular, it is not allowed to mix atomic and non-atomic accesses, or atomic accesses of different sizes, without synchronization._\n\n \n‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n\n","primitive.i128.html#method.forward_unchecked":"‼️`start` **Bounded**:\n > _`start` + `count` may overflow the range of values supported by `i128::MAX`._\n\n \n\n","primitive.pointer.html#method.sub-1":"‼️`self` **Allocated**:\n > __\n\n \n‼️`self` **Bounded**:\n > _The computed offset cannot exceed `isize::MAX` bytes._\n\n \n‼️`self` **Dereferencable**:\n > _Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object._\n\n \n\n","primitive.i16.html#method.unchecked_add":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self + rhs > i16::MAX` or `self + rhs < i16::MIN`._\n\n \n\n","net/struct.UdpSocket.html#method.from_raw_socket":"‼️`sock` **SystemIO**:\n > _`sock` must be an owned socket; in particular, it must be open._\n\n > _`sock` must be a socket that may be freed via `closesocket`._\n\n \n\n","num/struct.NonZeroI64.html#method.unchecked_mul":"‼️`self` **Bounded**:\n > _The behaviour is undefined as soon as `self * rhs > i64::MAX`, or `self * rhs < i64::MIN`._\n\n \n\n","primitive.i64.html#method.unchecked_shl":"‼️`self` **Bounded**:\n > _This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`._\n\n \n\n","alloc/trait.GlobalAlloc.html#method.realloc":"‼️`layout` **Layout**:\n > _`layout` has non-zero size._\n\n > _`layout` must be the same layout that was used to allocate that block of memory._\n\n \n‼️`new_size` **Bounded**:\n > _`new_size` must be greater than zero._\n\n > _`new_size`, when rounded up to the nearest multiple of `layout.align()`, must not overflow `isize::MAX`._\n\n \n‼️`ptr` **Allocated**:\n > _`ptr` must be currently allocated via this allocator._\n\n \n‼️`ptr` **Freed**:\n > _If this returns a non-null pointer, then ownership of the memory block referenced by `ptr` has been transferred to this allocator._\n\n \n‼️`retval` **Freed**:\n > _Returning a null pointer indicates that either memory is exhausted._\n\n \n‼️`retval` **Untyped**:\n > _The allocated block of memory may or may not be initialized._\n\n \n\n","primitive.pointer.html#method.copy_to":"‼️`dest` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`dest` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`dest` **DualOwned**:\n > _If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*dest` can violate memory safety. Note that assigning to `*dest` counts as a use because it will attempt to drop the value at `*dest`._\n\n \n‼️`dest` **Layout**:\n > _`dest` must be properly aligned._\n\n \n‼️`dest` **Leaked**:\n > __\n\n \n‼️`dest` **Untyped**:\n > _The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`._\n\n \n‼️`self` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned._\n\n \n\n","ptr/fn.read_volatile.html":"‼️`retval` **DualOwned**:\n > _If `T` is not `Copy`, using both the returned value and the value at `*src` can violate memory safety. Note that assigning to `*src` counts as a use because it will attempt to drop the value at `*src`._\n\n > _However, storing non-`Copy` types in volatile memory is almost certainly incorrect._\n\n \n‼️`src` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`src` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`src` **Initialized**:\n > _`src` must point to a properly initialized value of type `T`._\n\n \n‼️`src` **Layout**:\n > _`src` must be properly aligned._\n\n \n\n","primitive.u8.html#method.unchecked_add":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self + rhs > u8::MAX` or `self + rhs < u8::MIN`._\n\n \n\n","intrinsics/fn.frem_fast.html":"‼️`x` **Bounded**:\n > _Float remainder that allows optimizations based on algebraic rules. The calculated result cannot overflow `T::MAX` or `T::MIN`._\n\n \n\n","primitive.pointer.html#method.split_at_mut":"‼️`mid` **Bounded**:\n > _Panics if `mid` > `len`._\n\n > _`mid` must be in-bounds of the underlying allocated object._\n\n \n‼️`self` **Allocated**:\n > __\n\n \n‼️`self` **Dereferencable**:\n > _`self` must be dereferenceable and span a single allocation that is at least `mid * size_of::<T>()` bytes long._\n\n \n\n","primitive.pointer.html#method.write":"‼️`self` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned._\n\n \n‼️`self` **Leaked**:\n > _This is safe, but it could leak allocations or resources, so care should be taken not to overwrite an object that should be dropped._\n\n \n\n","boxed/struct.Box.html#method.from_raw_in":"‼️`retval` **DualOwned**:\n > _After calling this function, the raw pointer is owned by the resulting `Box`. A double-free may occur if the function is called twice on the same raw pointer._\n\n \n‼️`self` **Allocated**:\n > _For non-zero-sized values, a `Box` will use the in the given allocator for its allocation._\n\n > _For zero-sized values, the `Box` pointer still has to be valid for reads and writes (always be non-null pointers)._\n\n \n‼️`self` **Initialized**:\n > _Recreate a `Box` which was previously converted to a raw pointer using `Box::into_raw_with_allocator._\n\n > _It is valid to convert both ways between a `Box` and a raw pointer allocated with the given allocator, given that the `Layout` used with the allocator is correct for the type._\n\n \n‼️`self` **Layout**:\n > _The `Box` pointer has to be sufficiently aligned (always be fully aligned)._\n\n \n\n","num/struct.NonZeroU32.html#method.unchecked_mul":"‼️`self` **Bounded**:\n > _The behaviour is undefined as soon as `self * rhs > u32::MAX`._\n\n \n\n","primitive.u16.html#method.backward_unchecked":"‼️`start` **Bounded**:\n > _`start` - `count` may overflow the range of values supported by `u16::MIN`._\n\n \n\n","slice/fn.from_mut_ptr_range.html#":"‼️`range` **Allocated**:\n > _The `start` pointer of the range must be non-null even for zero-length slices._\n\n > _The `end` pointer of the range must be non-null even for zero-length slices._\n\n \n‼️`range` **Bounded**:\n > _The total length of the `range` must be no larger than `isize::MAX`._\n\n \n‼️`range` **Dereferencable**:\n > _The entire memory range of this slice must be contained within a single allocated object! Slices can never span across multiple allocated objects._\n\n \n‼️`range` **Initialized**:\n > _The range must contain `N` consecutive properly initialized values of type `T`._\n\n \n‼️`range` **Layout**:\n > _The `start` pointer of the range must be properly aligned to the first element of a slice._\n\n > _The `end` pointer of the range must be to one past the last element._\n\n > _This function panics if `T` is a Zero-Sized Type (ZST)._\n\n \n‼️`retval` **Aliased**:\n > _The memory referenced by the returned slice must not be mutated for the duration of lifetime `'a`._\n\n > _The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse, it's suggested to tie the lifetime to whichever source lifetime is safe in the context._\n\n \n\n","primitive.pointer.html#method.byte_sub-1":"‼️`self` **Allocated**:\n > __\n\n \n‼️`self` **Bounded**:\n > _The computed offset cannot exceed `isize::MAX` bytes._\n\n \n‼️`self` **Dereferencable**:\n > _Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object._\n\n \n\n","num/struct.NonZeroU16.html#method.unchecked_add":"‼️`self` **Bounded**:\n > _The behaviour is undefined as soon as `self + rhs > u16::MAX`._\n\n \n\n","net/struct.TcpListener.html#method.from_raw_socket":"‼️`sock` **SystemIO**:\n > _`sock` must be an owned socket; in particular, it must be open._\n\n > _`sock` must be a socket that may be freed via `closesocket`._\n\n \n\n","intrinsics/fn.ptr_offset_from.html":"‼️`origin` **Allocated**:\n > __\n\n \n‼️`origin` **Dereferencable**:\n > _`base` must be either in bounds or one byte past the end of the same allocated object._\n\n \n‼️`self` **Allocated**:\n > __\n\n \n‼️`self` **Bounded**:\n > _The distance between the pointers, in bytes, cannot overflow an `isize`._\n\n > _The distance between the pointers, in bytes, must be an exact multiple of the size of `T`._\n\n \n‼️`self` **Dereferencable**:\n > _`ptr` must be either in bounds or one byte past the end of the same allocated object._\n\n > _Both pointers must be derived from a pointer to the same object._\n\n \n‼️`self` **EST**:\n > _This function panics if `T` is a Zero-Sized Type (ZST)._\n\n \n\n","intrinsics/fn.assume.html":"‼️`b` **Bounded**:\n > _If the condition is false, the behavior is undefined._\n\n \n\n","primitive.i128.html#method.unchecked_shr":"‼️`self` **Bounded**:\n > _This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`._\n\n \n\n","sync/struct.Arc.html#method.decrement_strong_count_in":"‼️`ptr` **Allocated**:\n > _`ptr` must point to a block of memory allocated by allocated by `alloc` in the provided allocator._\n\n \n‼️`ptr` **Bounded**:\n > _The associated `Arc` instance must be valid (i.e. the strong count must be at least 1) when invoking this method._\n\n \n‼️`ptr` **Freed**:\n > _This method can be used to release the final `Arc` and backing storage, but should not be called after the final `Arc` has been released._\n\n \n‼️`ptr` **Initialized**:\n > _The pointer must have been obtained through `Arc::into_raw`._\n\n \n\n","primitive.i128.html#method.backward_unchecked":"‼️`start` **Bounded**:\n > _`start` - `count` may overflow the range of values supported by `i128::MIN`._\n\n \n\n","io/struct.BorrowedBuf.html#method.set_init":"‼️`self` **Initialized**:\n > _The caller must ensure that the first `n` unfilled bytes of the buffer have already been initialized._\n\n \n\n","primitive.i8.html#method.backward_unchecked":"‼️`start` **Bounded**:\n > _`start` - `count` may overflow the range of values supported by `i8::MIN`._\n\n \n\n","alloc/trait.GlobalAlloc.html#method.alloc_zeroed":"‼️`layout` **Layout**:\n > _`layout` has non-zero size._\n\n \n‼️`retval` **Freed**:\n > _Returning a null pointer indicates that either memory is exhausted._\n\n \n‼️`retval` **Untyped**:\n > _The allocated block of memory is guaranteed to be initialized but may be untyped._\n\n \n\n","primitive.u8.html#method.unchecked_shl":"‼️`self` **Bounded**:\n > _This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`._\n\n \n\n","ops/struct.RangeFrom.html#method.get_unchecked":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","ops/struct.Range.html#method.get_unchecked_mut":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","ptr/struct.NonNull.html#method.new_unchecked":"‼️`ptr` **Allocated**:\n > _`ptr` must be non-null._\n\n \n\n","boxed/struct.Box.html#method.from_raw":"‼️`retval` **DualOwned**:\n > _After calling this function, the raw pointer is owned by the resulting `Box`. A double-free may occur if the function is called twice on the same raw pointer._\n\n \n‼️`self` **Allocated**:\n > _For non-zero-sized values, a `Box` will use the Global allocator for its allocation._\n\n > _For zero-sized values, the `Box` pointer still has to be valid for reads and writes (always be non-null pointers)._\n\n \n‼️`self` **Initialized**:\n > _Recreate a `Box` which was previously converted to a raw pointer using `Box::into_raw`._\n\n > _It is valid to convert both ways between a `Box` and a raw pointer allocated with the Global allocator, given that the `Layout` used with the allocator is correct for the type._\n\n \n‼️`self` **Layout**:\n > _The `Box` pointer has to be sufficiently aligned (always be fully aligned)._\n\n \n\n","primitive.pointer.html#method.read_volatile-1":"‼️`retval` **DualOwned**:\n > _If `T` is not `Copy`, using both the returned value and the value at `self` can violate memory safety. Note that assigning to `self` counts as a use because it will attempt to drop the value at `self`._\n\n > _However, storing non-`Copy` types in volatile memory is almost certainly incorrect._\n\n \n‼️`self` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Initialized**:\n > _`self` must point to a properly initialized value of type `T`._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned._\n\n \n\n","any/trait.Any.html#method.downcast_mut_unchecked-1":"‼️`self` **Initialized**:\n > _The contained value must be of type `T`._\n\n \n\n","sync/struct.Arc.html#method.get_mut_unchecked":"‼️`retval` **Aliased**:\n > _If any other `Arc` or `Weak` pointers to the same allocation exist, then they must not be dereferenced or have active borrows for the duration of the returned borrow, and their inner type must be exactly the same as the inner type of this `Arc` (including lifetimes)._\n\n \n\n","primitive.i64.html#method.unchecked_shr":"‼️`self` **Bounded**:\n > _This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`._\n\n \n\n","slice/trait.SliceIndex.html#tymethod.get_unchecked":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","primitive.u16.html#method.unchecked_sub":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self - rhs > u16::MAX` or `self - rhs < u16::MIN`._\n\n \n\n","intrinsics/fn.exact_div.html":"‼️`x` **Bounded**:\n > _Resulting in undefined behavior where `x % y != 0`._\n\n > _Resulting in undefined behavior where `x == T::MIN && y == -1`._\n\n \n‼️`y` **Bounded**:\n > _Resulting in undefined behavior where `y == 0`._\n\n \n\n","primitive.i16.html#method.backward_unchecked":"‼️`start` **Bounded**:\n > _`start` - `count` may overflow the range of values supported by `i16::MIN`._\n\n \n\n","primitive.pointer.html#method.add":"‼️`self` **Allocated**:\n > __\n\n \n‼️`self` **Bounded**:\n > _The computed offset cannot exceed `isize::MAX` bytes._\n\n \n‼️`self` **Dereferencable**:\n > _Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object._\n\n \n\n","os/unix/net/struct.UnixListener.html#method.from_raw_fd":"‼️`fd` **SystemIO**:\n > _The `fd` passed in must be an owned file descriptor; in particular, it must be open._\n\n \n\n","primitive.i8.html#method.unchecked_shr":"‼️`self` **Bounded**:\n > _This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`._\n\n \n\n","primitive.u32.html#method.forward_unchecked":"‼️`start` **Bounded**:\n > _`start` + `count` may overflow the range of values supported by `u16::MAX`._\n\n \n\n","iter/trait.Step.html#method.backward_unchecked":"‼️`start` **Bounded**:\n > _`start` - `count` may overflow the range of values supported by `Self`._\n\n \n\n","primitive.usize.html#method.get_unchecked":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","rc/struct.Rc.html#method.get_mut_unchecked":"‼️`retval` **Aliased**:\n > _If any other `Rc` or `Weak` pointers to the same allocation exist, then they must not be dereferenced or have active borrows for the duration of the returned borrow, and their inner type must be exactly the same as the inner type of this `Rc` (including lifetimes)._\n\n \n\n","num/struct.NonZeroU8.html#method.new_unchecked":"‼️`n` **Bounded**:\n > _The value must not be zero._\n\n \n\n","mem/union.MaybeUninit.html#method.assume_init":"‼️`self` **Initialized**:\n > _It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized state._\n\n \n\n","str/fn.from_utf8_unchecked_mut.html":"‼️`v` **Initialized**:\n > _The bytes passed in must be valid UTF-8._\n\n \n\n","os/windows/io/struct.BorrowedHandle.html#method.borrow_raw":"‼️`handle` **SystemIO**:\n > _The resource pointed to by handle must be a valid open handle, it must remain open for the duration of the returned `BorrowedHandle`._\n\n \n\n","os/unix/net/struct.UnixStream.html#method.from_raw_fd":"‼️`fd` **SystemIO**:\n > _The `fd` passed in must be an owned file descriptor; in particular, it must be open._\n\n \n\n","primitive.i16.html#method.unchecked_mul":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self * rhs > i16::MAX` or `self * rhs < i16::MIN`._\n\n \n\n","ptr/fn.copy_nonoverlapping.html":"‼️`dst` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`dst` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n > _The region of memory beginning at `src` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `dst` with the same size._\n\n \n‼️`dst` **DualOwned**:\n > _If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*dst` can violate memory safety. Note that assigning to `*dst` counts as a use because it will attempt to drop the value at `*dst`._\n\n \n‼️`dst` **Layout**:\n > _`dst` must be properly aligned._\n\n \n‼️`dst` **Leaked**:\n > __\n\n \n‼️`dst` **Untyped**:\n > _The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`._\n\n \n‼️`src` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`src` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n > _The region of memory beginning at `src` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `dst` with the same size._\n\n \n‼️`src` **Layout**:\n > _`src` must be properly aligned._\n\n \n\n","primitive.pointer.html#method.offset_from":"‼️`origin` **Allocated**:\n > __\n\n \n‼️`origin` **Dereferencable**:\n > _`origin` must be either in bounds or one byte past the end of the same allocated object._\n\n \n‼️`self` **Allocated**:\n > __\n\n \n‼️`self` **Bounded**:\n > _The distance between the pointers, in bytes, cannot overflow an `isize`._\n\n > _The distance between the pointers, in bytes, must be an exact multiple of the size of `T`._\n\n \n‼️`self` **Dereferencable**:\n > _`self` must be either in bounds or one byte past the end of the same allocated object._\n\n > _Both pointers must be derived from a pointer to the same object._\n\n \n‼️`self` **Layout**:\n > _This function panics if `T` is a Zero-Sized Type (ZST)._\n\n \n\n","primitive.i16.html#method.unchecked_sub":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self - rhs > i16::MAX` or `self - rhs < i16::MIN`._\n\n \n\n","ops/struct.RangeInclusive.html#method.get_unchecked-1":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","primitive.pointer.html#method.read-1":"‼️`retval` **DualOwned**:\n > _If `T` is not `Copy`, using both the returned value and the value at `self` can violate memory safety. Note that assigning to `self` counts as a use because it will attempt to drop the value at `self`._\n\n \n‼️`self` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Initialized**:\n > _`self` must point to a properly initialized value of type `T`._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned._\n\n \n\n","ptr/struct.NonNull.html#method.replace":"‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Initialized**:\n > _`self` must point to a properly initialized value of type `T`._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned._\n\n \n‼️`src` **Leaked**:\n > _Neither value is dropped._\n\n \n\n","ops/struct.RangeFrom.html#method.get_unchecked-1":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","primitive.pointer.html#method.get_unchecked":"‼️`index` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting pointer is not used._\n\n \n‼️`self` **Dereferencable**:\n > _When `self` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","ops/struct.Range.html#method.get_unchecked_mut-1":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","ptr/struct.NonNull.html#method.byte_add":"‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Bounded**:\n > _The computed offset cannot exceed `isize::MAX` bytes._\n\n \n‼️`self` **Dereferencable**:\n > _Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object._\n\n \n\n","primitive.u128.html#method.unchecked_shl":"‼️`self` **Bounded**:\n > _This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`._\n\n \n\n","primitive.slice.html#method.split_at_unchecked":"‼️`mid` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used. The caller has to ensure that `0 <= mid <= self.len()`._\n\n \n\n","primitive.i8.html#method.forward_unchecked":"‼️`start` **Bounded**:\n > _`start` + `count` may overflow the range of values supported by `i8::MAX`._\n\n \n\n","slice/trait.SliceIndex.html#tymethod.get_unchecked_mut":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","primitive.i64.html#method.backward_unchecked":"‼️`start` **Bounded**:\n > _`start` - `count` may overflow the range of values supported by `i64::MIN`._\n\n \n\n","ptr/fn.swap_nonoverlapping.html":"‼️`x` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`x` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n > _The region of memory beginning at `x` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `y` with the same size._\n\n \n‼️`x` **Layout**:\n > _`x` must be properly aligned._\n\n \n‼️`x` **Untyped**:\n > _The operation is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`._\n\n \n‼️`y` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`y` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n > _The region of memory beginning at `x` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `y` with the same size._\n\n \n‼️`y` **Layout**:\n > _`y` must be properly aligned._\n\n \n‼️`y` **Untyped**:\n > _The operation is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`._\n\n \n\n","ptr/struct.NonNull.html#method.as_mut":"‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get accessed (read or written) through any other pointer._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Initialized**:\n > _The pointer must point to an initialized instance of `T`._\n\n \n‼️`self` **Layout**:\n > _The pointer must be properly aligned._\n\n \n\n","intrinsics/fn.fdiv_fast.html":"‼️`x` **Bounded**:\n > _Float division that allows optimizations based on algebraic rules. The calculated result cannot overflow `T::MAX` or `T::MIN`._\n\n \n\n","rc/struct.Rc.html#method.downcast_unchecked":"‼️`self` **Initialized**:\n > _The contained value must be of type `T`._\n\n \n\n","primitive.u64.html#method.forward_unchecked":"‼️`start` **Bounded**:\n > _`start` + `count` may overflow the range of values supported by `u64::MAX`._\n\n \n\n","num/struct.NonZeroU32.html#method.unchecked_add":"‼️`self` **Bounded**:\n > _The behaviour is undefined as soon as `self + rhs > u32::MAX`._\n\n \n\n","sync/struct.Arc.html#method.downcast_unchecked":"‼️`self` **Initialized**:\n > _The contained value must be of type `T`._\n\n \n\n","num/struct.NonZeroU128.html#method.unchecked_mul":"‼️`self` **Bounded**:\n > _The behaviour is undefined as soon as `self * rhs > u128::MAX`._\n\n \n\n","sync/atomic/struct.AtomicU16.html#method.from_ptr":"‼️`ptr` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`ptr` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`ptr` **Layout**:\n > _`ptr` must be aligned to `align_of::<AtomicU16>()`._\n\n \n‼️`ptr` **Thread**:\n > _You must adhere to the Memory model for atomic accesses. In particular, it is not allowed to mix atomic and non-atomic accesses, or atomic accesses of different sizes, without synchronization._\n\n \n‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n\n","intrinsics/fn.ptr_offset_from_unsigned.html":"‼️`base` **Allocated**:\n > __\n\n \n‼️`base` **Dereferencable**:\n > _`base` must be either in bounds or one byte past the end of the same allocated object._\n\n \n‼️`ptr` **Allocated**:\n > __\n\n \n‼️`ptr` **Bounded**:\n > _The distance between the pointers, in bytes, cannot overflow an `isize`._\n\n > _The distance between the pointers, in bytes, must be an exact multiple of the size of `T`._\n\n > _The distance between the pointers must be non-negative (`ptr` >= `base`)._\n\n \n‼️`ptr` **Dereferencable**:\n > _`ptr` must be either in bounds or one byte past the end of the same allocated object._\n\n > _Both pointers must be derived from a pointer to the same object._\n\n \n‼️`ptr` **EST**:\n > _This function panics if `T` is a Zero-Sized Type (ZST)._\n\n \n\n","primitive.pointer.html#method.as_uninit_mut":"‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get accessed (read or written) through any other pointer._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n‼️`self` **Allocated**:\n > _Either the pointer is null or all of the following is true._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Layout**:\n > _The pointer must be properly aligned._\n\n \n\n","ptr/struct.NonNull.html#method.copy_to_nonoverlapping":"‼️`dest` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`dest` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n > _The region of memory beginning at `self` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `dest` with the same size._\n\n \n‼️`dest` **DualOwned**:\n > _If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*dest` can violate memory safety. Note that assigning to `*dest` counts as a use because it will attempt to drop the value at `*dest`._\n\n \n‼️`dest` **Layout**:\n > _`dest` must be properly aligned._\n\n \n‼️`dest` **Leaked**:\n > __\n\n \n‼️`dest` **Untyped**:\n > _The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`._\n\n \n‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n > _The region of memory beginning at `self` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `dest` with the same size._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned._\n\n \n\n","ptr/struct.NonNull.html#method.swap":"‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Untyped**:\n > _The operation is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`._\n\n \n‼️`selfx` **Layout**:\n > _`self` must be properly aligned._\n\n \n‼️`with` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`with` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`with` **Layout**:\n > _`with` must be properly aligned._\n\n \n‼️`with` **Untyped**:\n > _The operation is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`._\n\n \n\n","primitive.pointer.html#method.swap":"‼️`self` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Untyped**:\n > _The operation is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`._\n\n \n‼️`selfx` **Layout**:\n > _`self` must be properly aligned._\n\n \n‼️`with` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`with` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`with` **Layout**:\n > _`with` must be properly aligned._\n\n \n‼️`with` **Untyped**:\n > _The operation is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`._\n\n \n\n","primitive.i8.html#method.unchecked_mul":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self * rhs > i8::MAX` or `self * rhs < i8::MIN`._\n\n \n\n","io/struct.BorrowedCursor.html#method.advance":"‼️`self` **Initialized**:\n > _The caller must ensure that the first `n` bytes of the cursor have been properly initialised._\n\n \n\n","primitive.u16.html#method.unchecked_add":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self + rhs > u16::MAX` or `self + rhs < u16::MIN`._\n\n \n\n","primitive.i128.html#method.unchecked_add":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self + rhs > i128::MAX` or `self + rhs < i128::MIN`._\n\n \n\n","ptr/struct.NonNull.html#method.copy_to":"‼️`dest` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`dest` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`dest` **DualOwned**:\n > _If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*dest` can violate memory safety. Note that assigning to `*dest` counts as a use because it will attempt to drop the value at `*dest`._\n\n \n‼️`dest` **Layout**:\n > _`dest` must be properly aligned._\n\n \n‼️`dest` **Leaked**:\n > __\n\n \n‼️`dest` **Untyped**:\n > _The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`._\n\n \n‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned._\n\n \n\n","primitive.u8.html#method.unchecked_mul":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self * rhs > u8::MAX` or `self * rhs < u8::MIN`._\n\n \n\n","primitive.str.html#method.slice_unchecked":"‼️`begin` **Bounded**:\n > _`begin` must not exceed `end`._\n\n > _`begin` must be byte positions within the string slice._\n\n \n‼️`begin` **Initialized**:\n > _`begin` must lie on UTF-8 sequence boundaries._\n\n \n‼️`end` **Bounded**:\n > _`end` must be byte positions within the string slice._\n\n \n‼️`end` **Initialized**:\n > _`end` must lie on UTF-8 sequence boundaries._\n\n \n\n","ops/struct.RangeFull.html#method.get_unchecked-1":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","mem/fn.transmute_copy.html":"‼️`retval` **Aliased**:\n > _It can turn a `*mut T` into an `&mut T`._\n\n > _It can extend a lifetime, or shorten an invariant lifetime._\n\n \n‼️`retval` **DualOwned**:\n > _It will also unsafely create a copy of the contained value instead of moving out of `src`._\n\n \n‼️`retval` **Untyped**:\n > _It is therefore your responsibility to guarantee that every value passed to transmute is valid at both types `Src` and `Dst`. Failing to uphold this condition may lead to unexpected and unstable compilation results._\n\n \n‼️`src` **Initialized**:\n > _Both the argument and the result must be valid at their given type._\n\n > _To transmute the inner type of the contents of a container, you must make sure to not violate any of the container's invariants._\n\n \n‼️`src` **Layout**:\n > _Both types must have the same size._\n\n > _Note that source and destination are passed by-value, which means if `Src` or `Dst` contain padding, that padding is not guaranteed to be preserved by transmute._\n\n > _When transmuting values that point elsewhere (such as pointers, references, boxes…), the caller has to ensure proper alignment of the pointed-to values._\n\n \n\n","iter/trait.Step.html#method.forward_unchecked":"‼️`start` **Bounded**:\n > _`start` + `count` may overflow the range of values supported by `Self`._\n\n \n\n","primitive.i16.html#method.forward_unchecked":"‼️`start` **Bounded**:\n > _`start` + `count` may overflow the range of values supported by `i16::MAX`._\n\n \n\n","mem/fn.align_of_val_raw.html":"‼️`val` **Bounded**:\n > _If the unsized tail of `T` is a slice, then the length of the slice tail must be an initialized integer, and the size of the entire value (dynamic tail length + statically sized prefix) must fit in `isize`._\n\n > _If the unsized tail of `T` is a trait object, then the vtable part of the pointer must point to a valid vtable for the type `T` acquired by an unsizing coercion, and the size of the entire value (dynamic tail length + statically sized prefix) must fit in `isize`._\n\n \n‼️`val` **Layout**:\n > _If the unsized tail of `T` is a slice, then the length of the slice tail must be an initialized integer, and the size of the entire value (dynamic tail length + statically sized prefix) must fit in `isize`._\n\n > _If the unsized tail of `T` is a trait object, then the vtable part of the pointer must point to a valid vtable for the type `T` acquired by an unsizing coercion, and the size of the entire value (dynamic tail length + statically sized prefix) must fit in `isize`._\n\n \n\n","alloc/trait.GlobalAlloc.html#tymethod.dealloc":"‼️`layout` **Layout**:\n > _`layout` must be the same layout that was used to allocate that block of memory._\n\n \n‼️`ptr` **Allocated**:\n > _`ptr` must denote a block of memory currently allocated via this allocator._\n\n \n\n","ptr/struct.NonNull.html#method.offset":"‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Bounded**:\n > _The computed offset, in bytes, cannot overflow an `isize`._\n\n \n‼️`self` **Dereferencable**:\n > _Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object._\n\n \n\n","mem/fn.zeroed.html":"‼️`retval` **Untyped**:\n > _The padding byte is not necessarily zeroed. There is no guarantee that an all-zero byte-pattern represents a valid value of some type `T`._\n\n \n\n","sync/atomic/struct.AtomicU32.html#method.from_ptr":"‼️`ptr` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`ptr` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`ptr` **Layout**:\n > _`ptr` must be aligned to `align_of::<AtomicU32>()`._\n\n \n‼️`ptr` **Thread**:\n > _You must adhere to the Memory model for atomic accesses. In particular, it is not allowed to mix atomic and non-atomic accesses, or atomic accesses of different sizes, without synchronization._\n\n \n‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n\n","primitive.pointer.html#method.as_uninit_ref":"‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n‼️`self` **Allocated**:\n > _Either the pointer is null or all of the following is true._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Layout**:\n > _The pointer must be properly aligned._\n\n \n\n","primitive.pointer.html#method.byte_sub":"‼️`self` **Allocated**:\n > __\n\n \n‼️`self` **Bounded**:\n > _The computed offset cannot exceed `isize::MAX` bytes._\n\n \n‼️`self` **Dereferencable**:\n > _Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object._\n\n \n\n","primitive.u128.html#method.unchecked_mul":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self * rhs > u128::MAX` or `self * rhs < u128::MIN`._\n\n \n\n","alloc/trait.Allocator.html#method.grow":"‼️`new_layout` **Bounded**:\n > _`new_layout.size()` must be greater than or equal to `old_layout.size()`._\n\n \n‼️`old_layout` **Layout**:\n > _`old_layout` must fit that block of memory._\n\n \n‼️`ptr` **Allocated**:\n > _`ptr` must denote a block of memory currently allocated via this allocator._\n\n \n‼️`ptr` **Freed**:\n > _If this returns `Ok`, then ownership of the memory block referenced by `ptr` has been transferred to this allocator. _\n\n \n‼️`retval` **Untyped**:\n > _The allocated block of memory may or may not be initialized._\n\n \n\n","num/struct.NonZeroU64.html#method.unchecked_mul":"‼️`self` **Bounded**:\n > _The behaviour is undefined as soon as `self * rhs > u64::MAX`._\n\n \n\n","primitive.u128.html#method.unchecked_shr":"‼️`self` **Bounded**:\n > _This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`._\n\n \n\n","str/fn.from_utf8_unchecked.html":"‼️`v` **Initialized**:\n > _The bytes passed in must be valid UTF-8._\n\n \n\n","ptr/struct.NonNull.html#method.write_unaligned":"‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Leaked**:\n > _This is safe, but it could leak allocations or resources, so care should be taken not to overwrite an object that should be dropped._\n\n \n\n","sync/atomic/struct.AtomicI16.html#method.from_ptr":"‼️`ptr` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`ptr` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`ptr` **Layout**:\n > _`ptr` must be aligned to `align_of::<AtomicI16>()`._\n\n \n‼️`ptr` **Thread**:\n > _You must adhere to the Memory model for atomic accesses. In particular, it is not allowed to mix atomic and non-atomic accesses, or atomic accesses of different sizes, without synchronization._\n\n \n‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n\n","ops/struct.RangeTo.html#method.get_unchecked_mut":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","primitive.pointer.html#method.byte_offset_from":"‼️`origin` **Allocated**:\n > __\n\n \n‼️`origin` **Dereferencable**:\n > _`origin` must be either in bounds or one byte past the end of the same allocated object._\n\n \n‼️`self` **Allocated**:\n > __\n\n \n‼️`self` **Bounded**:\n > _The distance between the pointers, in bytes, cannot overflow an `isize`._\n\n > _The distance between the pointers, in bytes, must be an exact multiple of the size of `T`._\n\n \n‼️`self` **Dereferencable**:\n > _`self` must be either in bounds or one byte past the end of the same allocated object._\n\n > _Both pointers must be derived from a pointer to the same object._\n\n \n‼️`self` **Layout**:\n > _This function panics if `T` is a Zero-Sized Type (ZST)._\n\n \n\n","sync/atomic/struct.AtomicU64.html#method.from_ptr":"‼️`ptr` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`ptr` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`ptr` **Layout**:\n > _`ptr` must be aligned to `align_of::<AtomicU64>()`._\n\n \n‼️`ptr` **Thread**:\n > _You must adhere to the Memory model for atomic accesses. In particular, it is not allowed to mix atomic and non-atomic accesses, or atomic accesses of different sizes, without synchronization._\n\n \n‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n\n","num/struct.NonZeroU64.html#method.unchecked_add":"‼️`self` **Bounded**:\n > _The behaviour is undefined as soon as `self + rhs > u64::MAX`._\n\n \n\n","net/struct.UdpSocket.html#method.from_raw_fd":"‼️`fd` **SystemIO**:\n > _The `fd` passed in must be an owned file descriptor; in particular, it must be open._\n\n \n\n","ops/struct.Range.html#method.get_unchecked-1":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","ptr/struct.NonNull.html#method.write_volatile":"‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned._\n\n \n‼️`self` **Leaked**:\n > _This is safe, but it could leak allocations or resources, so care should be taken not to overwrite an object that should be dropped._\n\n \n\n","boxed/struct.Box.html#method.downcast_unchecked-2":"‼️`self` **Initialized**:\n > _The contained value must be of type `T`._\n\n \n\n","intrinsics/fn.volatile_set_memory.html":"‼️`dst` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`dst` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`dst` **Layout**:\n > _`dst` must be properly aligned ('min_align_of::<T>()')._\n\n \n‼️`dst` **Leaked**:\n > __\n\n \n‼️`dst` **Untyped**:\n > _Additionally, note that changing `dst` in this way can easily lead to undefined behavior (UB) later if the written bytes are not a valid representation of some `T`._\n\n \n\n","primitive.slice.html#method.as_chunks_unchecked_mut":"‼️`self` **Bounded**:\n > _The slice splits exactly into `N`-element chunks (aka `self.len() % N == 0`)._\n\n > _`N != 0`._\n\n \n\n","os/fd/struct.OwnedFd.html#method.from_raw_fd":"‼️`fd` **SystemIO**:\n > _The resource pointed to by `fd` must be open and suitable for assuming ownership. The resource must not require any cleanup other than `close`._\n\n \n\n","ptr/struct.Alignment.html#method.new_unchecked":"‼️`align` **Bounded**:\n > _`align` must be a power of two._\n\n > _Equivalently, it must be `1 << exp` for some exp in `0..usize::BITS`. It must not be zero._\n\n \n\n","os/windows/io/trait.FromRawSocket.html#tymethod.from_raw_socket":"‼️`sock` **SystemIO**:\n > _`sock` must be an owned socket; in particular, it must be open._\n\n > _`sock` must be a socket that may be freed via `closesocket`._\n\n \n\n","primitive.u32.html#method.unchecked_sub":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self - rhs > u32::MAX` or `self - rhs < u32::MIN`._\n\n \n\n","any/trait.Any.html#method.downcast_mut_unchecked":"‼️`self` **Initialized**:\n > _The contained value must be of type `T`._\n\n \n\n","alloc/trait.Allocator.html#method.shrink":"‼️`new_layout` **Bounded**:\n > _`new_layout.size()` must be smaller than or equal to `old_layout.size()`._\n\n \n‼️`old_layout` **Layout**:\n > _`old_layout` must fit that block of memory._\n\n \n‼️`ptr` **Allocated**:\n > _`ptr` must denote a block of memory currently allocated via this allocator._\n\n \n‼️`ptr` **Freed**:\n > _If this returns `Ok`, then ownership of the memory block referenced by `ptr` has been transferred to this allocator. _\n\n \n\n","primitive.u16.html#method.unchecked_shr":"‼️`self` **Bounded**:\n > _This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`._\n\n \n\n","primitive.i128.html#method.unchecked_mul":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self * rhs > i128::MAX` or `self * rhs < i128::MIN`._\n\n \n\n","primitive.u64.html#method.backward_unchecked":"‼️`start` **Bounded**:\n > _`start` - `count` may overflow the range of values supported by `u64::MIN`._\n\n \n\n","ffi/struct.CString.html#method.from_raw":"‼️`ptr` **Allocated**:\n > _The raw pointer must point to a block of memory allocated by the global allocator._\n\n > _Other usage (trying to take ownership of a string that was allocated by foreign code) is likely to lead to undefined behavior or allocator corruption._\n\n \n‼️`ptr` **Initialized**:\n > _Owned, C-compatible, nul-terminated string with no nul bytes in the middle._\n\n > _This should only ever be called with a pointer that was earlier obtained by calling `CString::into_raw`._\n\n > _The recomputed length must match the original length from the `CString::into_raw` call. This means the `CString::into_raw/from_raw` methods should not be used when passing the string to C functions that can modify the string's length._\n\n \n‼️`retval` **DualOwned**:\n > _Retakes ownership of a `CString` that was transferred to C via `CString::into_raw`._\n\n \n\n","intrinsics/fn.unchecked_mul.html":"‼️`x` **Bounded**:\n > _Returns the result of an unchecked multiplication, resulting in undefined behavior when `x * y > T::MAX` or `x * y < T::MIN`._\n\n \n\n","primitive.i128.html#method.unchecked_sub":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self - rhs > i128::MAX` or `self - rhs < i128::MIN`._\n\n \n\n","intrinsics/fn.raw_eq.html":"‼️`a` **Initialized**:\n > _It's UB to call this if any of the bytes in `*a` are uninitialized or carry a pointer value._\n\n \n‼️`a` **Layout**:\n > _Note that this is a stricter criterion than just the values being fully-initialized: if `T` has padding, it's UB to call this intrinsic._\n\n \n‼️`b` **Initialized**:\n > _It's UB to call this if any of the bytes in `*b` are uninitialized or carry a pointer value._\n\n \n‼️`b` **Layout**:\n > _Note that this is a stricter criterion than just the values being fully-initialized: if `T` has padding, it's UB to call this intrinsic._\n\n \n\n","primitive.isize.html#method.backward_unchecked":"‼️`start` **Bounded**:\n > _`start` - `count` may overflow the range of values supported by `isize::MIN`._\n\n \n\n","char/fn.from_u32_unchecked.html":"‼️`i` **Initialized**:\n > _Not all valid `u32`s are valid `char`s, it may construct invalid `char` values._\n\n \n\n","primitive.i32.html#method.unchecked_shl":"‼️`self` **Bounded**:\n > _This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`._\n\n \n\n","sync/atomic/struct.AtomicIsize.html#method.from_ptr":"‼️`ptr` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`ptr` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`ptr` **Layout**:\n > _`ptr` must be aligned to `align_of::<AtomicIsize>()`._\n\n \n‼️`ptr` **Thread**:\n > _You must adhere to the Memory model for atomic accesses. In particular, it is not allowed to mix atomic and non-atomic accesses, or atomic accesses of different sizes, without synchronization._\n\n \n‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n\n","num/struct.NonZeroU16.html#method.new_unchecked":"‼️`n` **Bounded**:\n > _The value must not be zero._\n\n \n\n","ptr/struct.NonNull.html#method.as_uninit_ref":"‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Layout**:\n > _The pointer must be properly aligned._\n\n \n\n","primitive.pointer.html#method.as_uninit_ref-1":"‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n‼️`self` **Allocated**:\n > _Either the pointer is null or all of the following is true._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Layout**:\n > _The pointer must be properly aligned._\n\n \n\n","string/struct.String.html#method.from_utf8_unchecked":"‼️`bytes` **Initialized**:\n > _It does not check that the bytes passed to it are valid UTF-8._\n\n \n\n","sync/atomic/struct.AtomicI32.html#method.from_ptr":"‼️`ptr` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`ptr` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`ptr` **Layout**:\n > _`ptr` must be aligned to `align_of::<AtomicI32>()`._\n\n \n‼️`ptr` **Thread**:\n > _You must adhere to the Memory model for atomic accesses. In particular, it is not allowed to mix atomic and non-atomic accesses, or atomic accesses of different sizes, without synchronization._\n\n \n‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n\n","primitive.i8.html#method.unchecked_sub":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self - rhs > i8::MAX` or `self - rhs < i8::MIN`._\n\n \n\n","fs/struct.File.html#method.from_raw_handle":"‼️`handle` **SystemIO**:\n > _`handle` must be an owned handle; in particular, it must be open._\n\n > _`handle` must be a handle for a resource that may be freed via `CloseHandle`._\n\n \n\n","primitive.pointer.html#method.offset":"‼️`self` **Allocated**:\n > __\n\n \n‼️`self` **Bounded**:\n > _The computed offset, in bytes, cannot overflow an `isize`._\n\n \n‼️`self` **Dereferencable**:\n > _Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object._\n\n \n\n","num/struct.NonZeroIsize.html#method.new_unchecked":"‼️`n` **Bounded**:\n > _The value must not be zero._\n\n \n\n","ffi/struct.CString.html#method.from_vec_with_nul_unchecked":"‼️`v` **Initialized**:\n > _The given `Vec` must have one nul byte as its last element. This means it cannot be empty nor have any other nul byte anywhere else._\n\n \n\n","intrinsics/fn.transmute_unchecked.html":"‼️`retval` **Aliased**:\n > _It can turn a `*mut T` into an `&mut T`._\n\n > _It can extend a lifetime, or shorten an invariant lifetime._\n\n \n‼️`retval` **Initialized**:\n > _Both the argument and the result must be valid at their given type._\n\n \n‼️`retval` **Untyped**:\n > _It is therefore your responsibility to guarantee that every value passed to transmute is valid at both types `Src` and `Dst`. Failing to uphold this condition may lead to unexpected and unstable compilation results._\n\n \n‼️`src` **Initialized**:\n > _Both the argument and the result must be valid at their given type._\n\n > _To transmute the inner type of the contents of a container, you must make sure to not violate any of the container's invariants._\n\n \n‼️`src` **Layout**:\n > _Both types must have the same size._\n\n > _Note that source and destination are passed by-value, which means if `Src` or `Dst` contain padding, that padding is not guaranteed to be preserved by transmute._\n\n > _When transmuting values that point elsewhere (such as pointers, references, boxes…), the caller has to ensure proper alignment of the pointed-to values._\n\n \n\n","cell/struct.RefCell.html#method.try_borrow_unguarded":"‼️`retval` **Aliased**:\n > _Mutably borrowing the `RefCell` while the reference returned by this method is alive is undefined behaviour._\n\n \n\n","net/struct.TcpStream.html#method.from_raw_fd":"‼️`fd` **SystemIO**:\n > _The `fd` passed in must be an owned file descriptor; in particular, it must be open._\n\n \n\n","primitive.u8.html#method.forward_unchecked":"‼️`start` **Bounded**:\n > _`start` + `count` may overflow the range of values supported by `u8::MAX`._\n\n \n\n","primitive.i8.html#method.unchecked_add":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self + rhs > i8::MAX` or `self + rhs < i8::MIN`._\n\n \n\n","net/struct.TcpStream.html#method.from_raw_socket":"‼️`sock` **SystemIO**:\n > _`sock` must be an owned socket; in particular, it must be open._\n\n > _`sock` must be a socket that may be freed via `closesocket`._\n\n \n\n","num/struct.NonZeroU8.html#method.unchecked_add":"‼️`self` **Bounded**:\n > _The behaviour is undefined as soon as `self + rhs > u8::MAX`._\n\n \n\n","num/struct.NonZeroUsize.html#method.new_unchecked":"‼️`n` **Bounded**:\n > _The value must not be zero._\n\n \n\n","ops/struct.RangeToInclusive.html#method.get_unchecked_mut-1":"‼️`self` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Allocated**:\n > _A dangling slice pointer is undefined behavior even if the resulting reference is not used._\n\n \n‼️`slice` **Dereferencable**:\n > _When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used._\n\n \n\n","primitive.slice.html#method.swap_unchecked":"‼️`a` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior. The caller has to ensure that `a < self.len()`._\n\n \n‼️`b` **Bounded**:\n > _Calling this method with an out-of-bounds index is undefined behavior. The caller has to ensure that `b < self.len()`._\n\n \n\n","primitive.pointer.html#method.sub_ptr-1":"‼️`origin` **Allocated**:\n > __\n\n \n‼️`origin` **Dereferencable**:\n > _`origin` must be either in bounds or one byte past the end of the same allocated object._\n\n \n‼️`self` **Allocated**:\n > __\n\n \n‼️`self` **Bounded**:\n > _The distance between the pointers, in bytes, cannot overflow an `isize`._\n\n > _The distance between the pointers, in bytes, must be an exact multiple of the size of `T`._\n\n > _The distance between the pointers must be non-negative (`self` >= `origin`)._\n\n \n‼️`self` **Dereferencable**:\n > _`self` must be either in bounds or one byte past the end of the same allocated object._\n\n > _Both pointers must be derived from a pointer to the same object._\n\n \n‼️`self` **Layout**:\n > _This function panics if `T` is a Zero-Sized Type (ZST)._\n\n \n\n","ptr/struct.NonNull.html#method.read_volatile":"‼️`retval` **DualOwned**:\n > _If `T` is not `Copy`, using both the returned value and the value at `self` can violate memory safety. Note that assigning to `self` counts as a use because it will attempt to drop the value at `self`._\n\n > _However, storing non-`Copy` types in volatile memory is almost certainly incorrect._\n\n \n‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Initialized**:\n > _`self` must point to a properly initialized value of type `T`._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned._\n\n \n\n","pin/struct.Pin.html#method.get_unchecked_mut":"‼️`retval` **Pinned**:\n > _You will never move the data out of the mutable reference you receive when you call this function, so that the invariants on the `Pin` type can be upheld._\n\n \n\n","intrinsics/fn.volatile_copy_nonoverlapping_memory.html":"‼️`dst` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`dst` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n > _The region of memory beginning at `src` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `dst` with the same size._\n\n \n‼️`dst` **DualOwned**:\n > _If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*dst` can violate memory safety. Note that assigning to `*dst` counts as a use because it will attempt to drop the value at `*dst`._\n\n \n‼️`dst` **Layout**:\n > _`dst` must be properly aligned._\n\n \n‼️`dst` **Leaked**:\n > __\n\n \n‼️`dst` **Untyped**:\n > _The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`._\n\n \n‼️`src` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`src` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n > _The region of memory beginning at `src` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `dst` with the same size._\n\n \n‼️`src` **Layout**:\n > _`src` must be properly aligned._\n\n \n\n","intrinsics/fn.unchecked_add.html":"‼️`x` **Bounded**:\n > _Returns the result of an unchecked addition, resulting in undefined behavior when `x + y > T::MAX` or `x + y < T::MIN`._\n\n \n\n","primitive.slice.html#method.as_chunks_unchecked":"‼️`self` **Bounded**:\n > _The slice splits exactly into `N`-element chunks (aka `self.len() % N == 0`)._\n\n > _`N != 0`._\n\n \n\n","primitive.usize.html#method.unchecked_add":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self + rhs > usize::MAX` or `self + rhs < usize::MIN`._\n\n \n\n","intrinsics/fn.const_eval_select.html":"‼️`called_in_const` **Bounded**:\n > _The two functions must behave observably equivalent. Safe code in other crates may assume that calling a `const fn` at compile-time and at run-time produces the same result. A function that produces a different result when evaluated at run-time, or has any other observable side-effects, is unsound._\n\n \n\n","boxed/struct.Box.html#method.assume_init-1":"‼️`self` **Initialized**:\n > _It is up to the caller to guarantee that the value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior._\n\n \n\n","sync/struct.Arc.html#method.assume_init-1":"‼️`self` **Initialized**:\n > _It is up to the caller to guarantee that the inner value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior._\n\n \n\n","num/struct.NonZeroU32.html#method.new_unchecked":"‼️`n` **Bounded**:\n > _The value must not be zero._\n\n \n\n","primitive.pointer.html#method.copy_to-1":"‼️`dest` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`dest` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`dest` **DualOwned**:\n > _If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*dest` can violate memory safety. Note that assigning to `*dest` counts as a use because it will attempt to drop the value at `*dest`._\n\n \n‼️`dest` **Layout**:\n > _`dest` must be properly aligned._\n\n \n‼️`dest` **Leaked**:\n > __\n\n \n‼️`dest` **Untyped**:\n > _The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`._\n\n \n‼️`self` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Layout**:\n > _`self` must be properly aligned._\n\n \n\n","num/struct.NonZeroI16.html#method.unchecked_mul":"‼️`self` **Bounded**:\n > _The behaviour is undefined as soon as `self * rhs > i16::MAX`, or `self * rhs < i16::MIN`._\n\n \n\n","intrinsics/fn.volatile_copy_memory.html":"‼️`dst` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`dst` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`dst` **DualOwned**:\n > _If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*dst` can violate memory safety. Note that assigning to `*dst` counts as a use because it will attempt to drop the value at `*dst`._\n\n \n‼️`dst` **Layout**:\n > _`dst` must be properly aligned._\n\n \n‼️`dst` **Leaked**:\n > __\n\n \n‼️`dst` **Untyped**:\n > _The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`._\n\n \n‼️`src` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`src` **Dereferencable**:\n > _The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`src` **Layout**:\n > _`src` must be properly aligned._\n\n \n\n","sync/atomic/struct.AtomicI8.html#method.from_ptr":"‼️`ptr` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`ptr` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`ptr` **Layout**:\n > _`ptr` must be aligned to `align_of::<AtomicI8>()`._\n\n \n‼️`ptr` **Thread**:\n > _You must adhere to the Memory model for atomic accesses. In particular, it is not allowed to mix atomic and non-atomic accesses, or atomic accesses of different sizes, without synchronization._\n\n \n‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n\n","ptr/fn.write_volatile.html":"‼️`dst` **Allocated**:\n > _A null pointer is never valid, not even for accesses of size zero._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`dst` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`dst` **Layout**:\n > _`dst` must be properly aligned._\n\n \n‼️`dst` **Leaked**:\n > _This is safe, but it could leak allocations or resources, so care should be taken not to overwrite an object that should be dropped._\n\n \n\n","primitive.u64.html#method.unchecked_mul":"‼️`self` **Bounded**:\n > _This results in undefined behavior when `self * rhs > u64::MAX` or `self * rhs < u64::MIN`._\n\n \n\n","ptr/struct.NonNull.html#method.as_uninit_slice":"‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Bounded**:\n > _The total size `ptr.len() * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`._\n\n \n‼️`self` **Dereferencable**:\n > _The entire memory range of this slice (`ptr.len() * mem::size_of::<T>()` bytes) must be contained within a single allocated object! Slices can never span across multiple allocated objects._\n\n \n‼️`self` **Layout**:\n > _The pointer must be aligned even for zero-length slices._\n\n \n\n","primitive.usize.html#method.unchecked_shl":"‼️`self` **Bounded**:\n > _This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`._\n\n \n\n","ptr/struct.NonNull.html#method.as_ref":"‼️`retval` **Aliased**:\n > _You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated._\n\n > _The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data._\n\n \n‼️`self` **Allocated**:\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`self` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`self` **Initialized**:\n > _The pointer must point to an initialized instance of `T`._\n\n \n‼️`self` **Layout**:\n > _The pointer must be properly aligned._\n\n \n\n","primitive.u64.html#method.unchecked_shr":"‼️`self` **Bounded**:\n > _This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`._\n\n \n\n","ptr/fn.drop_in_place.html":"‼️`to_drop` **Allocated**:\n > _`to_drop` must be nonnull, even if T has size 0._\n\n > _Even for operations of size zero, the pointer must not be pointing to deallocated memory._\n\n \n‼️`to_drop` **Dereferencable**:\n > _The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object._\n\n \n‼️`to_drop` **Freed**:\n > _Executes the destructor (if any) of the pointed-to value._\n\n \n‼️`to_drop` **Initialized**:\n > _The value `to_drop` points to must be valid for dropping, which may mean it must uphold additional invariants. These invariants depend on the type of the value being dropped._\n\n \n‼️`to_drop` **Layout**:\n > _`to_drop` must be properly aligned, even if `T` has size 0._\n\n > _Unaligned values cannot be dropped in place, they must be copied to an aligned location first using `ptr::read_unaligned`._\n\n \n\n","rc/struct.Rc.html#method.assume_init-1":"‼️`self` **Initialized**:\n > _It is up to the caller to guarantee that the inner value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior._\n\n \n\n","alloc/struct.System.html#method.alloc_zeroed":"‼️`layout` **Layout**:\n > _`layout` has non-zero size._\n\n \n‼️`retval` **Freed**:\n > _Returning a null pointer indicates that either memory is exhausted._\n\n \n‼️`retval` **Untyped**:\n > _The allocated block of memory is guaranteed to be initialized but may be untyped._\n\n \n\n","rc/struct.Weak.html#method.from_raw":"‼️`ptr` **Allocated**:\n > _`ptr` must point to a block of memory allocated by the global allocator._\n\n \n‼️`ptr` **Initialized**:\n > _The pointer must have originated from the `Weak::into_raw` and must still own its potential weak reference._\n\n \n‼️`retval` **DualOwned**:\n > _It takes ownership of one weak reference. This can be used to deallocate the weak count by dropping the `Weak<T>`._\n\n \n\n","intrinsics/fn.fmul_fast.html":"‼️`x` **Bounded**:\n > _Float multiplication that allows optimizations based on algebraic rules. The calculated result cannot overflow `T::MAX` or `T::MIN`._\n\n \n\n","vec/struct.Vec.html#method.set_len":"‼️`new_len` **Bounded**:\n > _`new_len` must be less than or equal to `capacity()`._\n\n \n‼️`self` **Initialized**:\n > _The elements at `old_len..new_len` must be initialized._\n\n \n‼️`self` **Leaked**:\n > _There maybe a memory leak since the inner vectors were not freed prior to the `set_len` call._\n\n \n\n","alloc/struct.System.html#method.realloc":"‼️`layout` **Layout**:\n > _`layout` has non-zero size._\n\n > _`layout` must be the same layout that was used to allocate that block of memory._\n\n \n‼️`new_size` **Bounded**:\n > _`new_size` must be greater than zero._\n\n > _`new_size`, when rounded up to the nearest multiple of `layout.align()`, must not overflow `isize::MAX`._\n\n \n‼️`ptr` **Allocated**:\n > _`ptr` must be currently allocated via this allocator._\n\n \n‼️`ptr` **Freed**:\n > _If this returns a non-null pointer, then ownership of the memory block referenced by `ptr` has been transferred to this allocator._\n\n \n‼️`retval` **Freed**:\n > _Returning a null pointer indicates that either memory is exhausted._\n\n \n‼️`retval` **Untyped**:\n > _The allocated block of memory may or may not be initialized._\n\n \n\n"}}"#;